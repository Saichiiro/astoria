<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inventaire - Astoria</title>
    <link rel="icon" type="image/x-icon" href="assets/images/ALICE_ACADEMIA.ico">
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/inventaire.css">
</head>
<body>
            <!-- Main inventory wrapper -->
    <main class="inventory-wrapper" aria-labelledby="inventoryTitle">
                <!-- Header with title and back button -->
        <div class="inventory-header">
            <a href="codex.html" class="back-link" title="Retour à la liste">&#x2190;</a>
            <h1 class="inventory-title" id="inventoryTitle">Inventaire</h1>
            <div class="character-summary" aria-label="Résumé du personnage">
                <div class="character-avatar-wrapper">
                    <div class="character-avatar character-avatar--clickable" role="button" tabindex="0" aria-haspopup="true" aria-label="Changer de personnage">
                        <img class="character-avatar-img" id="characterSummaryAvatar" alt="Avatar" hidden>
                        <div class="character-avatar-circle" id="characterSummaryInitial" hidden></div>
                    </div>
                    <div class="character-dropdown" hidden aria-label="Sélectionner un personnage"></div>
                </div>
                <div class="character-summary-text">
                    <a class="character-name" id="characterSummaryName" href="profil.html">Nom du personnage</a>
                    <span class="character-tagline" id="characterSummaryTagline">Classe / Role / Surnom</span>
                    <div class="character-summary-meta">
                        <span class="stats-badge" id="characterKaelsBadge" hidden>0 kaels</span>
                        <div class="character-souls" id="characterSouls" hidden>
                            <span class="soul-count" title="&Acirc;mes consommation"><span class="soul-icon">🔥</span><span id="soulConsoValue">0</span></span>
                            <span class="soul-count" title="&Acirc;mes progression"><span class="soul-icon">⭐</span><span id="soulProgValue">0</span></span>
                        </div>
                    </div>
                </div>
            </div>
            <div class="inventory-actions">
                <span id="itemCount" class="inventory-info">0 objets</span>
                <button class="add-item-btn" id="openAddPanel" title="Ajouter un objet">
                    <span class="add-icon">+</span>
                    <span class="add-label">Ajouter</span>
                </button>
            </div>
        </div>
        <!-- Category filter bar + search -->
        <div class="inventory-toolbar">
            <nav class="inventory-categories" aria-label="Cat&eacute;gories d'inventaire">
                <button class="category-btn active" data-category="all">
                    <span class="category-icon">&#x1F4E6;</span>
                    <span class="category-label">Tous</span>
                </button>
                <button class="category-btn" data-category="equipement">
                    <span class="category-icon">&#x2694;&#xFE0F;</span>
                    <span class="category-label">&Eacute;quipements</span>
                </button>
                <button class="category-btn" data-category="consommable">
                    <span class="category-icon">&#x1F9EA;</span>
                    <span class="category-label">Consommables</span>
                </button>
                <button class="category-btn" data-category="agricole">
                    <span class="category-icon">&#x1F33E;</span>
                    <span class="category-label">Agricole</span>
                </button>
            </nav>

            <div class="inventory-search" id="inventorySearch">
                <button type="button" class="inventory-search-toggle" id="inventorySearchToggle" aria-label="Rechercher" aria-expanded="false">
                    <span class="inventory-search-icon">&#x1F50D;</span>
                </button>
                <input
                    type="search"
                    id="inventorySearchInput"
                    class="inventory-search-input"
                    placeholder="Rechercher un objet..."
                    aria-label="Rechercher un objet"
                >
                <button type="button" class="inventory-search-clear" id="inventorySearchClear" aria-label="Effacer la recherche" hidden>x</button>
                <div class="recent-searches-dropdown inventory-search-history" id="inventorySearchHistory"></div>
            </div>
        </div>

        <!-- Main content area: grid + details -->
        <div class="inventory-content">
            <!-- Items grid (left side) -->
                        <div class="inventory-grid-container">
                <div class="inventory-grid" id="inventoryGrid">
                    <!-- Items will be rendered here by JS -->
                </div>
                <div class="empty-inventory is-hidden" id="emptyState">
                    <div class="empty-state-icon">&#x1F4E6;</div>
                    <div class="empty-state-title">Aucun objet</div>
                    <div class="empty-state-message">Votre inventaire est vide dans cette catégorie</div>
                </div>
            </div>

            <!-- Item detail panel (right side) -->
                        <div class="inventory-detail" id="itemDetail">
                <div class="detail-placeholder">
                    <div class="placeholder-icon">&#x1F446;</div>
                    <p>Sélectionnez un objet pour voir ses détails</p>
                </div>
                <!-- Details will be rendered here when item is selected -->
            </div>

            <!-- Scroll types panel (right-most side) -->
            <aside class="scroll-types-panel" id="scrollTypesPanel" aria-hidden="true">
                <div class="scroll-panel-header">
                    <h3 id="scrollPanelTitle">Types de parchemins</h3>
                    <button class="scroll-panel-add-btn" id="scrollPanelAddBtn" type="button" title="Ajouter des parchemins" aria-label="Ajouter des parchemins" aria-expanded="false" aria-controls="scrollPanelAdd" disabled>+</button>
                </div>
                <div class="scroll-panel-body" id="scrollPanelBody">
                    <div class="scroll-panel-add" id="scrollPanelAdd" aria-hidden="true">
                        <div class="scroll-add-search">
                            <input type="text" id="scrollTypeSearch" placeholder="Rechercher un type">
                        </div>
                        <div class="scroll-suggestions" id="scrollTypeSuggestions"></div>
                    </div>
                    <p class="scroll-panel-empty" id="scrollPanelEmpty">Aucun type de parchemin disponible.</p>
                    <div class="scroll-panel-list" id="scrollPanelList"></div>
                </div>
            </aside>
        </div>
    </main>

    <!-- Add item panel (slide-in from right) -->
    <div class="add-panel" id="addPanel">
        <div class="add-panel-inner">
            <div class="add-panel-header">
                <h2>Ajouter un objet</h2>
                <button class="panel-close-btn" id="closeAddPanel">&times;</button>
            </div>

            <div class="add-panel-body">
                <!-- Item selector (from existing database) -->
                <div class="form-group">
                    <label for="itemSelect">Objet *</label>
                    <select id="itemSelect" required>
                        <option value="">-- Sélectionner un objet --</option>
                        <!-- Options populated by JS from inventoryData -->
                    </select>
                </div>

                                <!-- Category selector -->
                <div class="form-group">
                    <label for="categorySelect">Catégorie *</label>
                    <select id="categorySelect" required>
                        <option value="all">&#x1F4E6; Toutes catégories</option>
                        <option value="equipement">&#x2694;&#xFE0F; &Eacute;quipement</option>
                        <option value="consommable">&#x1F9EA; Consommable</option>
                        <option value="agricole">&#x1F33E; Agricole</option>
                    </select>
                </div>

                <!-- Quantity selector -->
                <div class="form-group">
                    <label for="quantityInput">Quantité *</label>
                    <div class="quantity-control">
                        <button type="button" class="qty-btn" id="qtyMinus">-</button>
                        <input type="number" id="quantityInput" min="1" value="1">
                        <button type="button" class="qty-btn" id="qtyPlus">+</button>
                    </div>
                </div>

                <!-- Item preview (shows selected item details) -->
                <div id="itemPreview" class="item-preview">
                    <div class="form-group">
                        <label>Aperçu</label>
                        <div class="item-preview-card">
                            <img id="previewImage" class="item-preview-image" src="" alt="" decoding="async">
                            <div>
                                <div class="item-preview-name" id="previewName"></div>
                                <div class="item-preview-description" id="previewDescription"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="add-panel-footer">
                <button type="button" class="btn-secondary" id="cancelAdd">Annuler</button>
                <button type="button" class="btn-primary" id="confirmAdd">Ajouter</button>
            </div>
        </div>
    </div>

    <!-- Delete confirmation modal -->
    <div class="delete-modal-overlay" id="deleteModal">
        <div class="delete-modal">
            <div class="delete-modal-header">
                <h3>Supprimer l'objet</h3>
            </div>
            <div class="delete-modal-body">
                <p>Combien d'unités de <span class="delete-modal-item-name" id="deleteItemName"></span> voulez-vous supprimer ?</p>
                <div class="form-group">
                    <label for="deleteQuantityInput">Quantité à supprimer</label>
                    <div class="quantity-control">
                        <button type="button" class="qty-btn" id="deleteQtyMinus">-</button>
                        <input type="number" id="deleteQuantityInput" min="1" value="1">
                        <button type="button" class="qty-btn" id="deleteQtyPlus">+</button>
                    </div>
                </div>
            </div>
            <div class="delete-modal-footer">
                <button type="button" class="btn-secondary" id="cancelDelete">Annuler</button>
                <button type="button" class="btn-danger" id="confirmDelete">Supprimer</button>
            </div>
        </div>
    </div>

    <!-- Load shared data -->
    <script src="js/image-helpers.js"></script>
    <script src="js/data.js"></script>
    <script src="js/ui/list-helpers.js"></script>
    <script src="js/ui/search-history.js"></script>
    <script src="js/ui/searchbar.js"></script>
    <script type="module" src="js/ui/app-shell.js"></script>
    <script type="module">
        import { initCharacterSummary } from './js/ui/character-summary.js';
        // Initialize character summary with kaels and dropdown
        document.addEventListener('DOMContentLoaded', async () => {
            await initCharacterSummary({ enableDropdown: true, showKaels: true });
        });
    </script>

    <!-- Inventory-specific JS -->
    <script>
        (function () {
        /**
         * ========================================================================
         * INVENTORY MODULE - EMPTY BY DEFAULT WITH ADD PANEL
         * ========================================================================
         *
         * TEMPORARY IMPLEMENTATION FOR TESTING:
         * - Inventory starts EMPTY on first load
         * - Items stored in localStorage for persistence (testing only)
         * - Items are added via "+" panel which selects from existing database
         * - All item data (name, description, image) comes from data.js
         *
         * FUTURE INTEGRATION:
         * - Replace localStorage with real backend API
         * - Load inventory from server instead of localStorage
         * - Connect to global item management system
         * ========================================================================
         */

        // =================================================================
        // CONFIGURATION
        // =================================================================
        /**
         * IMAGE CONFIGURATION & PLACEHOLDER
         * Délégués au helper global image-helpers.js
         */
        const INVENTORY_IMAGE_HELPERS = window.astoriaImageHelpers || {};
        const PLACEHOLDER_IMAGE = INVENTORY_IMAGE_HELPERS.smallPlaceholder;

        const SCROLL_TYPES = [
            { key: 'feu', emoji: '🔥', label: 'Feu', matchers: ['feu'] },
            { key: 'eau', emoji: '💧', label: 'Eau', matchers: ['eau'] },
            { key: 'vent', emoji: '🌪️', label: 'Vent', matchers: ['vent'] },
            { key: 'terre', emoji: '🌱', label: 'Terre', matchers: ['terre'] },
            { key: 'nature', emoji: '🍃', label: 'Nature', matchers: ['nature'] },
            { key: 'roche', emoji: '🪨', label: 'Roche', matchers: ['roche'] },
            { key: 'metaux', emoji: '⚙️', label: 'Métaux', matchers: ['metaux', 'métaux'] },
            { key: 'cryo', emoji: '❄️', label: 'Cryo (glace)', matchers: ['cryo', 'glace'] },
            { key: 'foudre', emoji: '⚡', label: 'Foudre', matchers: ['foudre'] },
            { key: 'lumiere', emoji: '☀️', label: 'Lumière', matchers: ['lumiere', 'lumière'] },
            { key: 'tenebres', emoji: '🌑', label: 'Ténèbres', matchers: ['tenebres', 'ténèbres'] },
            { key: 'bois', emoji: '🌲', label: 'Bois', matchers: ['bois'] },
            { key: 'boue', emoji: '🟫', label: 'Boue', matchers: ['boue'] },
            { key: 'lave', emoji: '🌋', label: 'Lave', matchers: ['lave'] },
            { key: 'acide', emoji: '☣️', label: 'Acide', matchers: ['acide'] },
            { key: 'cristal', emoji: '💎', label: 'Cristal', matchers: ['cristal'] },
            { key: 'gravite', emoji: '🌀', label: 'Gravité', matchers: ['gravite', 'gravité'] },
            { key: 'osmose', emoji: '🧿', label: 'Osmose', matchers: ['osmose'] },
            { key: 'telekinesie', emoji: '🧠', label: 'Télékinésie', matchers: ['telekinesie', 'télékinésie'] },
            { key: 'invisibilite', emoji: '👁️', label: 'Invisibilité', matchers: ['invisibilite', 'invisibilité'] },
            { key: 'vol', emoji: '🕊️', label: 'Vol', matchers: ['vol'] },
            { key: 'soin', emoji: '💗', label: 'Soin', matchers: ['soin'] },
            { key: 'amelioration-sens', emoji: '👂', label: 'Amélioration des sens', matchers: ['amelioration des sens', 'amélioration des sens'] },
            { key: 'reve', emoji: '💭', label: 'Rêve', matchers: ['reve', 'rêve'] },
            { key: 'controle-mental', emoji: '🧿', label: 'Contrôle mental', matchers: ['controle mental', 'contrôle mental'] },
            { key: 'controle-temps', emoji: '⏳', label: 'Contrôle du Temps', matchers: ['controle du temps', 'controle temps', 'contrôle du temps', 'contrôle temps'] },
            { key: 'portals', emoji: '🌀', label: 'Portals', matchers: ['portals', 'portal', 'portail', 'portails'] },
            { key: 'monde-poche', emoji: '🧳', label: 'Monde de poche', matchers: ['monde de poche'] },
            { key: 'teleportation', emoji: '🧭', label: 'Téléportation', matchers: ['teleportation', 'téléportation'] },
            { key: 'mana-brut', emoji: '💥', label: 'Mana brut', matchers: ['mana brut'] },
            { key: 'ordre', emoji: '⚖️', label: 'Ordre', matchers: ['ordre'] },
            { key: 'antimagie', emoji: '⛔', label: 'Antimagie', matchers: ['antimagie'] },
            { key: 'amelioration-runique', emoji: '🔷', label: 'Amélioration runique', matchers: ['amelioration runique', 'amélioration runique'] },
            { key: 'invocation-energie', emoji: '✨', label: 'Invocation d’énergie', matchers: ['invocation d energie', 'invocation energie', 'invocation d’énergie'] },
            { key: 'amplification-elementaire', emoji: '📣', label: 'Amplification élémentaire', matchers: ['amplification elementaire', 'amplification élémentaire'] },
            { key: 'rotation', emoji: '↩️', label: 'Rotation', matchers: ['rotation'] },
            { key: 'magnetisme', emoji: '🧲', label: 'Magnétisme', matchers: ['magnetisme', 'magnétisme'] },
            { key: 'fil', emoji: '🧵', label: 'Fil', matchers: ['fil'] },
            { key: 'sable', emoji: '🏜️', label: 'Sable', matchers: ['sable'] },
            { key: 'ombres-solides', emoji: '🧱', label: 'Ombres solides', matchers: ['ombres solides'] },
            { key: 'verre', emoji: '🟣', label: 'Verre', matchers: ['verre'] },
            { key: 'cendres', emoji: '⚫', label: 'Cendres', matchers: ['cendres'] },
            { key: 'argile', emoji: '🧱', label: 'Argile', matchers: ['argile'] },
            { key: 'invocation-animale', emoji: '🐾', label: 'Invocation animale', matchers: ['invocation animale'] },
            { key: 'invocation-armes', emoji: '⚔️', label: 'Invocation d’armes', matchers: ['invocation d armes', 'invocation armes', 'invocation d’armes'] },
            { key: 'invocation-golems', emoji: '🪨', label: 'Invocation de golems', matchers: ['invocation de golems', 'invocation golems'] },
            { key: 'esprits-elementaires', emoji: '🧚', label: 'Esprits élémentaires', matchers: ['esprits elementaires', 'esprits élémentaires'] },
            { key: 'pantins', emoji: '🧸', label: 'Pantins', matchers: ['pantins'] },
            { key: 'fabrication-familiers', emoji: '🧸', label: 'Fabrication de familiers', matchers: ['fabrication de familiers', 'familiers'] },
            { key: 'metamorphose-animale', emoji: '🦎', label: 'Métamorphose animale', matchers: ['metamorphose animale', 'métamorphose animale'] },
            { key: 'mutations', emoji: '🧬', label: 'Mutations', matchers: ['mutations'] },
            { key: 'regeneration-avancee', emoji: '🩹', label: 'Régénération avancée', matchers: ['regeneration avancee', 'régénération avancée'] },
            { key: 'microbiologie', emoji: '🦠', label: 'MicroBiologie', matchers: ['microbiologie'] },
            { key: 'son', emoji: '🎵', label: 'Son', matchers: ['son'] },
            { key: 'illusion', emoji: '🎭', label: 'Illusion', matchers: ['illusion'] },
            { key: 'sang', emoji: '🩸', label: 'Sang', matchers: ['sang'] },
            { key: 'chance', emoji: '🍀', label: 'Chance / Malchance', matchers: ['chance', 'malchance'] },
            { key: 'lien', emoji: '🔗', label: 'Lien', matchers: ['lien'] },
            { key: 'detection', emoji: '🧿', label: 'Détection', matchers: ['detection', 'détection'] },
            { key: 'silence', emoji: '🤫', label: 'Silence', matchers: ['silence'] },
            { key: 'corruption', emoji: '🟣', label: 'Corruption', matchers: ['corruption'] },
            { key: 'cercle-demoniaque', emoji: '🕯️', label: 'Cercle démoniaque', matchers: ['cercle demoniaque', 'cercle démoniaque'] },
            { key: 'devoreur-ames', emoji: '💀', label: 'Dévoreur d’âmes', matchers: ['devoreur d ames', 'devoreur ames', 'dévoreur d’âmes'] },
            { key: 'rouille', emoji: '🧪', label: 'Rouille', matchers: ['rouille'] },
            { key: 'berserker', emoji: '🔥', label: 'Berserker', matchers: ['berserker'] },
            { key: 'maledictions', emoji: '☠️', label: 'Malédictions', matchers: ['maledictions', 'malédictions'] },
            { key: 'variation-masse', emoji: '🧍', label: 'Variation de masse', matchers: ['variation de masse'] },
            { key: 'meteorologie', emoji: '🌦️', label: 'Météorologie', matchers: ['meteorologie', 'météorologie'] },
            { key: 'chimie-magique', emoji: '⚗️', label: 'Chimie magique', matchers: ['chimie magique'] },
            { key: 'magie-astral', emoji: '🌌', label: 'Magie astral', matchers: ['magie astral', 'magie astrale'] },
            { key: 'elasticite', emoji: '🧶', label: '\u00c9lasticit\u00e9', matchers: ['elasticite', '\u00e9lasticit\u00e9'] }
        ];

        // =================================================================
        // =================================================================
        // STATE
        // =================================================================

        let currentCategory = 'all';
        let currentSearchQuery = '';
        let selectedItemIndex = null;
        let inventoryItems = []; // Starts EMPTY
        let nextItemId = 1; // Auto-increment ID for new items
        let inventoryStorageMode = 'local'; // 'local' | 'character'
        let authApi = null;
        let inventoryApi = null;
        let pendingProfileSaveTimer = null;
        let scrollPanelOpen = false;
        let scrollPanelCategory = null;
        let scrollPanelToggleBtn = null;
        let scrollAddOpen = false;
        let currentScrollItem = null;
        let selectedScrollTypeKey = null;
        let lastScrollItemId = null;
        let scrollTypeStore = {};
        let inventoryMigrated = false;

        // DOM REFERENCES
        // =================================================================

        const grid = document.getElementById('inventoryGrid');
        const detailPanel = document.getElementById('itemDetail');
        const emptyState = document.getElementById('emptyState');
        const emptyStateMessage = emptyState ? emptyState.querySelector('.empty-state-message') : null;
        const itemCountEl = document.getElementById('itemCount');
        const categoryButtons = document.querySelectorAll('.category-btn');
        const searchRoot = document.getElementById('inventorySearch');
        const searchInput = document.getElementById('inventorySearchInput');
        const searchToggle = document.getElementById('inventorySearchToggle');
        const searchClear = document.getElementById('inventorySearchClear');
        const searchHistoryDropdown = document.getElementById('inventorySearchHistory');
        const inventoryContent = document.querySelector('.inventory-content');
        const scrollTypesPanel = document.getElementById('scrollTypesPanel');
        const scrollPanelTitle = document.getElementById('scrollPanelTitle');
        const scrollPanelBody = document.getElementById('scrollPanelBody');
        const scrollPanelHeader = document.querySelector('.scroll-panel-header');
        const scrollPanelAddBtn = document.getElementById('scrollPanelAddBtn');
        const scrollPanelEmpty = document.getElementById('scrollPanelEmpty');
        const scrollPanelList = document.getElementById('scrollPanelList');
        const scrollPanelAdd = document.getElementById('scrollPanelAdd');
        const scrollTypeSearch = document.getElementById('scrollTypeSearch');
        const scrollTypeSuggestions = document.getElementById('scrollTypeSuggestions');

        // Add panel elements
        const addPanel = document.getElementById('addPanel');
        const openAddBtn = document.getElementById('openAddPanel');
        const closeAddBtn = document.getElementById('closeAddPanel');
        const cancelAddBtn = document.getElementById('cancelAdd');
        const confirmAddBtn = document.getElementById('confirmAdd');
        const itemSelect = document.getElementById('itemSelect');
        const categorySelect = document.getElementById('categorySelect');
        const quantityInput = document.getElementById('quantityInput');
        const qtyMinusBtn = document.getElementById('qtyMinus');
        const qtyPlusBtn = document.getElementById('qtyPlus');
        const itemPreview = document.getElementById('itemPreview');
        const previewImage = document.getElementById('previewImage');
        const previewName = document.getElementById('previewName');
        const previewDescription = document.getElementById('previewDescription');
        const inventoryWrapper = document.querySelector('.inventory-wrapper');
        let inventoryAccessAllowed = true;

        const listHelpers = window.astoriaListHelpers || {};
        const filterItems = listHelpers.filterItems;
        const searchFields = [
            (item) => item?.name,
            (item) => item?.description,
            (item) => item?.effect
        ];

        const searchHistory = window.astoriaSearchHistory
            ? window.astoriaSearchHistory.createSearchHistory({
                storageKey: 'astoriaInventoryRecentSearches',
                maxItems: 4
            })
            : null;

        const INVENTORY_SYNC_KEY = 'astoria_inventory_sync';

        function broadcastInventorySync(reason = 'update') {
            try {
                const character = authApi?.getActiveCharacter?.();
                if (!character?.id) return;
                const payload = {
                    characterId: String(character.id),
                    reason,
                    ts: Date.now()
                };
                localStorage.setItem(INVENTORY_SYNC_KEY, JSON.stringify(payload));
            } catch (error) {
                console.warn('Inventory sync broadcast failed:', error);
            }
        }

        async function handleInventorySync(payload) {
            if (!payload) return;
            if (inventoryStorageMode !== 'character' || !authApi) return;
            const character = authApi.getActiveCharacter?.();
            if (!character?.id) return;
            if (String(payload.characterId) !== String(character.id)) return;

            await loadInventory();
            syncCurrencyItem();
            renderInventory();
        }

        window.addEventListener('storage', (event) => {
            if (event.key !== INVENTORY_SYNC_KEY || !event.newValue) return;
            try {
                const payload = JSON.parse(event.newValue);
                void handleInventorySync(payload);
            } catch {
                // ignore invalid payloads
            }
        });

        // =================================================================
        // INITIALIZATION
        // =================================================================

        /**
         * Initialize inventory - EMPTY BY DEFAULT
         * - Loads from localStorage ONLY (if present)
         * - Otherwise displays empty inventory
         * - Renders the UI
         */
        async function initInventory() {
            console.log('Initializing inventory...');

            await hydrateItemsFromDb();
            await initInventoryStorage();
            if (!inventoryAccessAllowed) {
                renderInventoryAccessDenied();
                return;
            }
            await loadInventory();
            syncCurrencyItem();

            // Render
            renderInventory();

            // Note: Item selector is populated when add panel opens
        }

        // =================================================================
        // ITEM DATABASE ACCESS
        // =================================================================

        /**
         * TEMPORARY FUNCTION: Get all available items from data.js
         *
         * This function accesses our existing central item database (inventoryData).
         * In production, this would query the real backend database.
         *
         * @returns {Array} All available items from the game database
         */
        function getAllItems() {
            if (typeof inventoryData === 'undefined' || !inventoryData) {
                console.warn('inventoryData not found in data.js');
                return [];
            }
            return inventoryData.filter((item) =>
                !isLocalItemTombstoned(item) && !isItemDisabled(item)
            );
        }

        function safeJson(value) {
            if (!value) return {};
            if (typeof value === 'object') return value;
            if (typeof value === 'string') {
                try {
                    return JSON.parse(value);
                } catch {
                    return {};
                }
            }
            return {};
        }

        function normalizeItemName(name) {
            return String(name || '')
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '')
                .replace(/[^a-zA-Z0-9]+/g, '')
                .toLowerCase();
        }

        const ITEM_TOMBSTONES_KEY = 'astoriaItemTombstones';
        let disabledItemNames = new Set();

        function getItemTombstones() {
            try {
                const raw = localStorage.getItem(ITEM_TOMBSTONES_KEY);
                const parsed = raw ? JSON.parse(raw) : [];
                return Array.isArray(parsed) ? parsed : [];
            } catch {
                return [];
            }
        }

        function isLocalItemTombstoned(item) {
            if (!item || item._dbId || item.source === 'db') return false;
            const key = normalizeItemName(item.name || item.nom || '');
            if (!key) return false;
            const tombstones = getItemTombstones();
            return tombstones.includes(key);
        }

        function isItemDisabled(item) {
            const key = normalizeItemName(item?.name || item?.nom || '');
            if (!key) return false;
            return disabledItemNames.has(key);
        }

        function resolveItemByKey(itemKey, itemIndex) {
            const allItems = getAllItems();
            const numericIndex = Number.isFinite(Number(itemIndex)) ? Number(itemIndex) : null;
            if (numericIndex != null && numericIndex >= 0 && allItems[numericIndex]) {
                return { item: allItems[numericIndex], index: numericIndex };
            }

            const numericKey = Number.isFinite(Number(itemKey)) ? Number(itemKey) : null;
            if (numericKey != null && numericKey >= 0 && allItems[numericKey]) {
                return { item: allItems[numericKey], index: numericKey };
            }

            const normalizedKey = normalizeItemName(itemKey);
            if (normalizedKey) {
                const byName = allItems.findIndex((entry) =>
                    normalizeItemName(entry?.name || entry?.nom || '') === normalizedKey
                );
                if (byName >= 0) {
                    return { item: allItems[byName], index: byName };
                }
            }

            return { item: null, index: -1 };
        }

        async function reconcileInventoryRows(characterId, rows) {
            if (!characterId || !inventoryApi?.setInventoryItem || !Array.isArray(rows)) return rows;

            const canonicalByName = new Map();
            rows.forEach((row) => {
                const key = normalizeItemName(row?.item_key);
                if (!key) return;
                if (!canonicalByName.has(key)) canonicalByName.set(key, row);
            });

            const updates = [];
            const nextRows = [];

            rows.forEach((row) => {
                const resolved = resolveItemByKey(row?.item_key, row?.item_index);
                const canonicalKey = resolved?.item?.name ? String(resolved.item.name) : '';
                const canonicalNorm = normalizeItemName(canonicalKey);
                const rowNorm = normalizeItemName(row?.item_key);

                if (!canonicalKey || !canonicalNorm || !rowNorm || canonicalNorm === rowNorm) {
                    nextRows.push(row);
                    return;
                }

                const canonicalRow = canonicalByName.get(canonicalNorm);
                if (canonicalRow) {
                    // Canonical row already exists, drop the legacy key row.
                    updates.push(inventoryApi.setInventoryItem(characterId, String(row.item_key), row?.item_index, 0));
                    return;
                }

                // Migrate legacy key to canonical name.
                updates.push(inventoryApi.setInventoryItem(characterId, String(row.item_key), row?.item_index, 0));
                updates.push(inventoryApi.setInventoryItem(characterId, canonicalKey, resolved.index, row?.qty));
                nextRows.push({
                    ...row,
                    item_key: canonicalKey,
                    item_index: Number.isFinite(resolved.index) && resolved.index >= 0 ? resolved.index : row?.item_index
                });
            });

            if (updates.length) {
                try {
                    await Promise.allSettled(updates);
                } catch (error) {
                    console.warn('Inventory reconcile failed:', error);
                }
            }

            return nextRows;
        }

        function mapDbItem(row) {
            const images = safeJson(row.images);
            const primary = images.primary || images.url || row.image || row.image_url || '';
            const buyText = row.price_pa ? `${row.price_pa} pa` : '';
            const sellText = row.price_po ? `${row.price_po} po` : '';
            return {
                _dbId: row.id,
                source: 'db',
                name: row.name || '',
                description: row.description || '',
                effect: row.effect || '',
                category: row.category || '',
                buyPrice: buyText,
                sellPrice: sellText,
                image: primary,
                images: images
            };
        }

        async function hydrateItemsFromDb() {
            if (!Array.isArray(window.inventoryData)) return;
            try {
                const itemsApi = await import('./js/api/items-service.js');
                if (!itemsApi?.getAllItems) return;
                const rows = await itemsApi.getAllItems();
                if (!Array.isArray(rows) || rows.length === 0) return;
                disabledItemNames = new Set(
                    rows
                        .filter((row) => row && row.enabled === false)
                        .map((row) => normalizeItemName(row.name || row.nom || ''))
                        .filter(Boolean)
                );
                const mapped = rows
                    .filter((row) => row && row.enabled !== false)
                    .map(mapDbItem);
                const nameToIndex = new Map();
                window.inventoryData.forEach((item, idx) => {
                    const key = normalizeItemName(item?.name || item?.nom || '');
                    if (key) nameToIndex.set(key, idx);
                });
                mapped.forEach((item) => {
                    if (!item || !item.name) return;
                    const key = normalizeItemName(item.name);
                    const existingIndex = nameToIndex.get(key);
                    if (existingIndex != null) {
                        window.inventoryData[existingIndex] = {
                            ...window.inventoryData[existingIndex],
                            ...item
                        };
                        return;
                    }
                    window.inventoryData.push(item);
                    nameToIndex.set(key, window.inventoryData.length - 1);
                });
            } catch (error) {
                console.warn('Inventory DB items load failed:', error);
            }
        }

        /**
         * Populate the item selector dropdown with items from database
         * Filters by selected category for clarity
         */
        function populateItemSelector() {
            const allItems = getAllItems();
            const selectedCategory = categorySelect.value;

            // Clear existing options (except the first placeholder)
            itemSelect.innerHTML = '<option value="">-- Sélectionner un objet --</option>';

            // Filter items by category if not "all"
            const filteredItems = selectedCategory === 'all'
                ? allItems
                : allItems.filter(item => item.category === selectedCategory);

            // Add filtered items as options
            filteredItems.forEach((item, index) => {
                // Use the original index from allItems for referencing
                const originalIndex = allItems.indexOf(item);
                const option = document.createElement('option');
                option.value = originalIndex; // Use original index to reference the item
                option.textContent = item.name;
                option.dataset.category = item.category;
                itemSelect.appendChild(option);
            });
        }

        // =================================================================
        // PERSISTENCE - LocalStorage (TEMPORARY)
        // =================================================================

        function hydrateInventoryFromCompact(items) {
            const allItems = getAllItems();
            inventoryItems = [];
            nextItemId = 1;

            if (!Array.isArray(items)) return;

            items.forEach((entry) => {
                const idx = Number(entry?.idx);
                const qty = Number(entry?.qty);
                if (!Number.isFinite(idx) || !Number.isFinite(qty) || qty <= 0) return;

                const sourceItem = allItems[idx];
                if (!sourceItem) return;

                inventoryItems.push({
                    id: nextItemId++,
                    sourceIndex: idx,
                    name: sourceItem.name,
                    category: sourceItem.category,
                    image: sourceItem.image,
                    description: sourceItem.description,
                    effect: sourceItem.effect,
                    buyPrice: sourceItem.buyPrice,
                    sellPrice: sourceItem.sellPrice,
                    quantity: Math.floor(qty)
                });
            });
        }


        function hydrateInventoryFromRows(rows) {
            const allItems = getAllItems();
            inventoryItems = [];
            nextItemId = 1;
            const missingRows = [];

            if (!Array.isArray(rows)) return;

            rows.forEach((row) => {
                const qty = Number(row?.qty);
                if (!Number.isFinite(qty) || qty <= 0) return;
                const resolved = resolveItemByKey(row?.item_key, row?.item_index);
                const sourceItem = resolved.item;
                if (!sourceItem) {
                    missingRows.push(row);
                    return;
                }

                inventoryItems.push({
                    id: nextItemId++,
                    sourceIndex: resolved.index,
                    ...sourceItem,
                    quantity: Math.floor(qty)
                });
            });
            return missingRows;
        }

        function buildInventoryRows(characterId) {
            return inventoryItems
                .map((item) => {
                    if (item?.isCurrency) return null;
                    const qty = Math.floor(Number(item?.quantity) || 0);
                    if (qty <= 0) return null;
                    const resolved = resolveItemByKey(item?.name, item?.sourceIndex);
                    const idx = resolved.index;
                    const itemKey = item?.name || resolved.item?.name;
                    if (!itemKey) return null;
                    return {
                        character_id: characterId,
                        item_key: String(itemKey),
                        item_index: Number.isFinite(idx) && idx >= 0 ? idx : null,
                        qty
                    };
                })
                .filter(Boolean);
        }

        function serializeInventoryForProfile() {
            const totalQty = inventoryItems.reduce((sum, item) => {
                if (item?.isCurrency) return sum;
                const qty = Math.floor(Number(item?.quantity) || 0);
                return sum + (Number.isFinite(qty) ? qty : 0);
            }, 0);

            return {
                version: 1,
                migrated: true,
                itemCount: inventoryItems.filter((item) => !item?.isCurrency).length,
                totalQty,
                scrollTypes: normalizeScrollTypeStore(scrollTypeStore)
            };
        }

        function syncCurrencyItem() {
            if (!authApi || typeof authApi.getActiveCharacter !== 'function') return;
            const character = authApi.getActiveCharacter();
            const rawKaels = Number(character?.kaels ?? 0);
            if (!Number.isFinite(rawKaels)) return;
            const kaels = Math.max(0, Math.floor(rawKaels));
            const existing = inventoryItems.find((item) => item?.isCurrency);
            if (existing) {
                existing.quantity = kaels;
                return;
            }
            inventoryItems.unshift({
                id: 0,
                name: 'Kaels',
                category: 'consommable',
                description: "Monnaie officielle d'Astoria.",
                effect: 'Utilisee pour acheter et vendre.',
                quantity: kaels,
                isCurrency: true
            });
        }


        function renderInventoryAccessDenied() {
            if (!inventoryWrapper) return;
            inventoryWrapper.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">LOCK</div>
                    <div class="empty-state-title">Acces restreint</div>
                    <div class="empty-state-message">
                        Seul le proprietaire du personnage ou un administrateur peut consulter cet inventaire.
                    </div>
                </div>
            `;
        }


        async function initInventoryStorage() {
            inventoryStorageMode = 'local';
            authApi = null;
            inventoryApi = null;

            try {
                authApi = await import('./js/auth.js');
                inventoryApi = await import('./js/api/inventory-service.js');
                const user = authApi.getCurrentUser?.();
                const character = authApi.getActiveCharacter?.();
                const isAdmin = authApi.isAdmin?.() || false;
                if (user && character && character.id) {
                    inventoryStorageMode = 'character';
                    if (character.user_id && !isAdmin && character.user_id !== user.id) {
                        inventoryAccessAllowed = false;
                    }
                }
            } catch (error) {
                // No server / module blocked / auth module unavailable => stay in local mode
                inventoryStorageMode = 'local';
                authApi = null;
                inventoryApi = null;
            }
        }



        async function loadInventory() {
            if (inventoryStorageMode !== 'character' || !authApi || !inventoryApi) {
                loadFromLocalStorage();
                return;
            }

            const character = authApi.getActiveCharacter?.();
            const payload = character?.profile_data?.inventory;
            const hasMigrated = payload?.migrated === true;
            inventoryMigrated = hasMigrated;

            if (payload && payload.scrollTypes && typeof payload.scrollTypes === 'object') {
                scrollTypeStore = payload.scrollTypes;
            } else {
                scrollTypeStore = {};
            }

            try {
                const rows = await inventoryApi.getInventoryRows?.(character?.id);
                if (Array.isArray(rows)) {
                    if (rows.length > 0) {
                        const normalizedRows = await reconcileInventoryRows(character?.id, rows);
                        const missingRows = hydrateInventoryFromRows(normalizedRows) || [];
                        console.log(`Loaded ${inventoryItems.length} items from character_inventory`);
                        if (missingRows.length) {
                            await cleanupMissingInventoryRows(character?.id, missingRows);
                        }
                        return;
                    }

                    if (!hasMigrated) {
                        loadFromLocalStorage();
                        if (inventoryItems.length > 0) {
                            console.log('Migrating local inventory to character_inventory...');
                            await saveInventoryToBackend();
                            return;
                        }
                    } else {
                        try {
                            localStorage.removeItem('astoriaInventory');
                        } catch {
                            // ignore cleanup failures
                        }
                    }

                    hydrateInventoryFromRows([]);
                    return;
                }
            } catch (error) {
                console.warn('Inventory load error (character_inventory):', error);
            }
            hydrateInventoryFromRows([]);
        }

        async function cleanupMissingInventoryRows(characterId, rows) {
            if (!characterId || !inventoryApi?.setInventoryItem) return;
            const deletions = rows.map((row) => {
                const key = row?.item_key ?? row?.item_index;
                if (key == null) return null;
                return inventoryApi.setInventoryItem(characterId, String(key), row?.item_index, 0);
            }).filter(Boolean);
            if (!deletions.length) return;
            try {
                await Promise.allSettled(deletions);
                console.log(`Removed ${deletions.length} missing inventory items.`);
            } catch (error) {
                console.warn('Failed to cleanup missing inventory items:', error);
            }
        }

        async function saveInventoryToCharacterProfile() {
            if (inventoryStorageMode !== 'character' || !authApi) return;

            const character = authApi.getActiveCharacter?.();
            if (!character || !character.id) return;

            const currentProfileData = character.profile_data || {};
            const nextProfileData = {
                ...currentProfileData,
                inventory: serializeInventoryForProfile(),
            };

            try {
                const res = await authApi.updateCharacter?.(character.id, { profile_data: nextProfileData });
                if (!res || !res.success) {
                    console.warn('Inventory save failed (profile_data).');
                }
            } catch (error) {
                console.warn('Inventory save error (profile_data):', error);
            }
        }

        async function saveInventoryToBackend() {
            if (inventoryStorageMode !== 'character' || !authApi || !inventoryApi) return;

            const character = authApi.getActiveCharacter?.();
            if (!character || !character.id) return;

            const rows = buildInventoryRows(character.id);
            let saved = false;

            try {
                await inventoryApi.replaceInventoryRows?.(character.id, rows);
                saved = true;
            } catch (error) {
                console.warn('Inventory save error (character_inventory):', error);
            }

            await saveInventoryToCharacterProfile();
            if (saved) {
                broadcastInventorySync('save');
            }
        }

        function persistInventory() {
            // Always keep local backup (handy for offline testing)
            saveToLocalStorage();

            if (inventoryStorageMode !== 'character') return;

            if (pendingProfileSaveTimer) {
                clearTimeout(pendingProfileSaveTimer);
                pendingProfileSaveTimer = null;
            }

            pendingProfileSaveTimer = setTimeout(() => {
                pendingProfileSaveTimer = null;
                void saveInventoryToBackend();
            }, 500);
        }

        /**
         * TEMPORARY: Load inventory from localStorage
         *
         * For testing purposes only. In production, this will be replaced
         * with a proper API call to load the user's inventory from the server.
         *
         * Storage key: 'astoriaInventory'
         * Format: JSON array of inventory items with quantities
         */
        function loadFromLocalStorage() {
            try {
                const stored = localStorage.getItem('astoriaInventory');
                if (stored) {
                    const parsed = JSON.parse(stored);
                    if (Array.isArray(parsed)) {
                        inventoryItems = parsed;
                    } else if (parsed && Array.isArray(parsed.items)) {
                        // Allow reading compact format if we ever store it locally too
                        hydrateInventoryFromCompact(parsed.items);
                    } else {
                        inventoryItems = [];
                    }
                    nextItemId = Math.max(...inventoryItems.map(i => i.id), 0) + 1;
                    console.log(`Loaded ${inventoryItems.length} items from localStorage`);
                } else {
                    inventoryItems = [];
                    console.log('No inventory found in localStorage - starting empty');
                }
            } catch (error) {
                console.error('Error loading from localStorage:', error);
                inventoryItems = [];
            }
        }

        /**
         * TEMPORARY: Save inventory to localStorage
         *
         * For testing purposes only. In production, this will be replaced
         * with API calls to persist changes to the server.
         */
        function saveToLocalStorage() {
            try {
                localStorage.setItem('astoriaInventory', JSON.stringify(inventoryItems));
                console.log('Inventory saved to localStorage');
            } catch (error) {
                console.error('Error saving to localStorage:', error);
            }
        }

        // =================================================================
        // ADD ITEM PANEL
        // =================================================================

        /**
         * Open the add item panel
         * Pre-selects the current category filter for convenience
         */
        function openAddPanel() {
            addPanel.classList.add('open');

            // Pre-select current category (or "all" if viewing all)
            categorySelect.value = currentCategory;

            // Populate items based on pre-selected category
            populateItemSelector();

            // Reset other form fields
            itemSelect.value = '';
            quantityInput.value = 1;
            itemPreview.style.display = 'none';
        }

        /**
         * Close the add item panel
         */
        function closeAddPanel() {
            addPanel.classList.remove('open');
            resetAddForm();
        }

        /**
         * Reset the add form to defaults
         */
        function resetAddForm() {
            itemSelect.value = '';
            categorySelect.value = 'all';
            quantityInput.value = 1;
            itemPreview.style.display = 'none';
            populateItemSelector(); // Refresh item list
        }

        /**
         * Handle category change - refresh item dropdown
         */
        function handleCategoryChange() {
            // Refresh item dropdown with filtered items
            populateItemSelector();

            // Clear item selection since list changed
            itemSelect.value = '';
            itemPreview.style.display = 'none';
        }

        /**
         * Handle item selection - show preview
         */
        function handleItemSelection() {
            const selectedIndex = itemSelect.value;

            if (!selectedIndex) {
                itemPreview.style.display = 'none';
                return;
            }

            const allItems = getAllItems();
            const selectedItem = allItems[parseInt(selectedIndex)];

            if (selectedItem) {
                // Show preview
                const imageSrc = resolveImage(selectedItem);
                previewImage.src = imageSrc;
                previewImage.onerror = () => { previewImage.src = PLACEHOLDER_IMAGE; };
                previewName.textContent = selectedItem.name;
                previewDescription.textContent = selectedItem.description || 'Aucune description disponible.';
                itemPreview.style.display = 'block';
            }
        }

        /**
         * Add selected item to inventory
         */
        function addItemToInventory() {
            const selectedIndex = itemSelect.value;
            const quantity = parseInt(quantityInput.value) || 1;

            if (!selectedIndex) {
                alert('Veuillez sélectionner un objet');
                return;
            }

            if (quantity < 1) {
                alert('La quantité doit être au moins 1');
                return;
            }

            const allItems = getAllItems();
            const sourceItem = allItems[parseInt(selectedIndex)];
            const sourceIndex = parseInt(selectedIndex);

            if (!sourceItem) {
                alert('Objet invalide');
                return;
            }

            // Check if item already exists in inventory
            const existingItem = inventoryItems.find(i => i.sourceIndex === sourceIndex || i.name === sourceItem.name);

            if (existingItem) {
                // Update quantity if already exists
                existingItem.quantity += quantity;
                if (!Number.isFinite(Number(existingItem.sourceIndex))) {
                    existingItem.sourceIndex = sourceIndex;
                }
                console.log(`Updated ${existingItem.name}: quantity now ${existingItem.quantity}`);
            } else {
                // Add new item with all data from source (use original category from data)
                const newItem = {
                    id: nextItemId++,
                    sourceIndex,
                    name: sourceItem.name,
                    category: sourceItem.category, // Use original category from data
                    image: sourceItem.image,
                    description: sourceItem.description,
                    effect: sourceItem.effect,
                    buyPrice: sourceItem.buyPrice,
                    sellPrice: sourceItem.sellPrice,
                    quantity: quantity
                };

                inventoryItems.push(newItem);
                console.log(`Added ${newItem.name} x${quantity} to inventory`);
            }

            persistInventory();

            // Close panel and refresh display
            closeAddPanel();
            renderInventory();
        }

        /**
         * Quantity control buttons
         */
        function decreaseQuantity() {
            const current = parseInt(quantityInput.value) || 1;
            quantityInput.value = Math.max(1, current - 1);
        }

        function increaseQuantity() {
            const current = parseInt(quantityInput.value) || 1;
            quantityInput.value = current + 1;
        }

        // Attach event listeners for add panel
        openAddBtn.addEventListener('click', openAddPanel);
        closeAddBtn.addEventListener('click', closeAddPanel);
        cancelAddBtn.addEventListener('click', closeAddPanel);
        confirmAddBtn.addEventListener('click', addItemToInventory);
        categorySelect.addEventListener('change', handleCategoryChange);
        itemSelect.addEventListener('change', handleItemSelection);
        qtyMinusBtn.addEventListener('click', decreaseQuantity);
        qtyPlusBtn.addEventListener('click', increaseQuantity);
        document.addEventListener('keydown', (event) => {
            if (event.key !== 'Escape') return;
            if (addPanel.classList.contains('open')) {
                closeAddPanel();
            }
        });

        if (scrollPanelAddBtn) {
            scrollPanelAddBtn.addEventListener('click', () => {
                if (scrollPanelAddBtn.disabled) return;
                setScrollAddOpen(!scrollAddOpen);
                renderScrollSuggestions(scrollTypeSearch?.value || '');
                syncScrollPanelHeights();
            });
        }

        if (scrollTypeSearch) {
            scrollTypeSearch.addEventListener('input', (event) => {
                renderScrollSuggestions(event.target.value);
                syncScrollPanelHeights();
            });
        }

        if (scrollTypeSuggestions) {
            scrollTypeSuggestions.addEventListener('click', (event) => {
                const addButton = event.target.closest('.scroll-suggestion-add');
                if (!addButton) return;
                const row = addButton.closest('.scroll-suggestion-row');
                if (!row) return;
                const qtyInput = row.querySelector('.scroll-suggestion-qty');
                addScrollTypeCount(row.dataset.typeKey, qtyInput?.value);
                if (qtyInput) qtyInput.value = 1;
            });
        }

        if (scrollPanelList) {
            scrollPanelList.addEventListener('click', (event) => {
                const addButton = event.target.closest('.scroll-type-add');
                const removeButton = event.target.closest('.scroll-type-remove');
                const qtyButton = event.target.closest('.scroll-type-qty-btn');
                const item = event.target.closest('.scroll-type-item');
                if (!item) return;
                const typeKey = item.dataset.typeKey;
                if (addButton) {
                    const qtyInput = item.querySelector('.scroll-type-qty-input');
                    addScrollTypeCount(typeKey, qtyInput?.value);
                    if (qtyInput) qtyInput.value = 1;
                    return;
                }
                if (removeButton) {
                    const qtyInput = item.querySelector('.scroll-type-qty-input');
                    removeScrollTypeCount(typeKey, qtyInput?.value);
                    if (qtyInput) qtyInput.value = 1;
                    return;
                }
                if (qtyButton) {
                    const qtyInput = item.querySelector('.scroll-type-qty-input');
                    if (!qtyInput) return;
                    const current = parseInt(qtyInput.value, 10) || 1;
                    const action = qtyButton.dataset.action;
                    qtyInput.value = Math.max(1, action === 'minus' ? current - 1 : current + 1);
                    return;
                }
                const row = event.target.closest('.scroll-type-row');
                if (row) {
                    selectedScrollTypeKey = typeKey;
                    if (currentScrollItem && scrollPanelCategory) {
                        const { counts } = loadScrollCounts(scrollPanelCategory, currentScrollItem);
                        renderScrollPanelList(scrollPanelCategory, counts);
                    }
                }
            });

            scrollPanelList.addEventListener('keydown', (event) => {
                if (event.key !== 'Enter') return;
                const input = event.target.closest('.scroll-type-qty-input');
                if (!input) return;
                const item = input.closest('.scroll-type-item');
                if (!item) return;
                addScrollTypeCount(item.dataset.typeKey, input.value);
                input.value = 1;
            });
        }

        window.addEventListener('resize', syncScrollPanelHeights);

        // =================================================================
        // CATEGORY FILTERING
        // =================================================================

        /**
         * Filter inventory by category
         * - Updates active button
         * - Clears selection
         * - Re-renders grid
         */
        function filterByCategory(category) {
            currentCategory = category;
            selectedItemIndex = null;

            // Update active button
            categoryButtons.forEach(btn => {
                if (btn.dataset.category === category) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            renderInventory();
        }

        // Attach click handlers to category buttons
        categoryButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                filterByCategory(btn.dataset.category);
            });
        });

        if (searchRoot && searchInput && window.astoriaSearchBar) {
            window.astoriaSearchBar.bind({
                root: searchRoot,
                input: searchInput,
                toggle: searchToggle,
                clearButton: searchClear,
                dropdown: searchHistoryDropdown,
                history: searchHistory,
                hotkey: ' ',
                debounceWait: 200,
                onSearch: (value) => {
                    currentSearchQuery = String(value || '').trim().toLowerCase();
                    renderInventory();
                }
            });
        }

        // =================================================================
        // IMAGE RESOLUTION
        // =================================================================

        /**
         * Resolve image path from item data
         * - Checks IMAGE_CONFIG mappings
         * - Supports direct URLs
         * - Falls back to placeholder
         */
        function resolveImage(item) {
            const helpers = window.astoriaImageHelpers || {};

            if (helpers.resolveItemImages) {
                const resolved = helpers.resolveItemImages(item);
                if (resolved && resolved.primary) {
                    return resolved.primary;
                }
            }

            // Fallback local (au cas où le helper n'est pas disponible)
            if (item) {
                const raw = item.image || item.img || item?.images?.primary || item?.images?.url || '';
                if (raw && (raw.startsWith('http') || raw.startsWith('data:'))) {
                    return raw;
                }
            }

            // No match found, use placeholder
            return PLACEHOLDER_IMAGE;
        }

        // =================================================================
        // SCROLL TYPES PANEL
        // =================================================================
        const normalizeText = window.astoriaListHelpers.normalizeText;

        function getScrollCategory(item) {
            if (!item || !item.name) return null;
            const name = normalizeText(item.name);
            if (!name.includes('parchemin') && !name.includes('scroll')) return null;
            if (name.includes('eveil') || name.includes('eveille') || (name.includes('veil') && name.includes('parchemin'))) return 'eveil';
            if (name.includes('ascension')) return 'ascension';
            return null;
        }

        function getScrollTypeKey(item) {
            const haystack = normalizeText(
                [item?.name, item?.description, item?.effect]
                    .filter(Boolean)
                    .join(' ')
            );

            for (const type of SCROLL_TYPES) {
                for (const matcher of type.matchers) {
                    if (haystack.includes(normalizeText(matcher))) {
                        return type.key;
                    }
                }
            }

            return null;
        }

        const SCROLL_STORAGE_PREFIX = 'astoriaScrollTypes:v1';

        function getEmptyScrollCounts() {
            const counts = {};
            SCROLL_TYPES.forEach((type) => {
                counts[type.key] = 0;
            });
            return counts;
        }

        function getScrollItemKey(item) {
            const sourceIndex = Number(item?.sourceIndex);
            if (Number.isFinite(sourceIndex)) {
                return `idx:${sourceIndex}`;
            }
            const name = item?.name ? normalizeText(item.name) : '';
            if (name) {
                return `name:${name}`;
            }
            const id = Number(item?.id);
            if (Number.isFinite(id)) {
                return `id:${id}`;
            }
            return 'unknown';
        }

        function getScrollStorageKey(category, item, useLegacy = false) {
            const idPart = useLegacy ? (item?.id ?? item?.name ?? 'unknown') : getScrollItemKey(item);
            return `${SCROLL_STORAGE_PREFIX}:${category}:${idPart}`;
        }

        function clearScrollCountsForItem(item) {
            const category = getScrollCategory(item);
            if (!category || !item) return;
            const itemKey = getScrollItemKey(item);
            if (scrollTypeStore?.[category]) {
                delete scrollTypeStore[category][itemKey];
                if (Object.keys(scrollTypeStore[category]).length === 0) {
                    delete scrollTypeStore[category];
                }
            }
            const key = getScrollStorageKey(category, item, false);
            const legacyKey = getScrollStorageKey(category, item, true);
            try {
                localStorage.removeItem(key);
                if (legacyKey !== key) {
                    localStorage.removeItem(legacyKey);
                }
            } catch {
                // ignore storage cleanup failures
            }
        }

        function resetScrollCountsAfterQtyChange(item) {
            const category = getScrollCategory(item);
            if (!category) return;
            clearScrollCountsForItem(item);
            const nextQty = Math.max(0, Math.floor(Number(item?.quantity) || 0));
            const seededTypeKey = getScrollTypeKey(item);
            if (seededTypeKey && nextQty > 0) {
                const counts = getEmptyScrollCounts();
                counts[seededTypeKey] = nextQty;
                saveScrollCounts(category, item, counts);
            } else {
                persistInventory();
            }
        }

        function normalizeScrollCounts(rawCounts) {
            const counts = getEmptyScrollCounts();
            if (!rawCounts) return counts;
            Object.keys(counts).forEach((typeKey) => {
                const value = Number(rawCounts[typeKey]);
                counts[typeKey] = Number.isFinite(value) && value > 0 ? value : 0;
            });
            return counts;
        }

        function buildScrollItemKeyMap() {
            const map = {};
            inventoryItems.forEach((item) => {
                const category = getScrollCategory(item);
                if (!category) return;
                if (!map[category]) {
                    map[category] = new Set();
                }
                map[category].add(getScrollItemKey(item));
            });
            return map;
        }

        function normalizeScrollTypeStore(rawStore) {
            if (!rawStore || typeof rawStore !== 'object') return {};
            const allowedKeys = buildScrollItemKeyMap();
            const cleaned = {};

            Object.entries(rawStore).forEach(([category, items]) => {
                if (!items || typeof items !== 'object') return;
                if (!allowedKeys[category]) return;
                const cleanedItems = {};

                Object.entries(items).forEach(([itemKey, entry]) => {
                    if (!allowedKeys[category].has(itemKey)) return;
                    const counts = normalizeScrollCounts(entry?.counts);
                    const hasAny = Object.values(counts).some((value) => value > 0);
                    if (!hasAny) return;
                    cleanedItems[itemKey] = {
                        counts,
                        updatedAt: entry?.updatedAt || Date.now()
                    };
                });

                if (Object.keys(cleanedItems).length) {
                    cleaned[category] = cleanedItems;
                }
            });

            return cleaned;
        }

        function getScrollStoreEntry(category, item) {
            if (!scrollTypeStore || typeof scrollTypeStore !== 'object') return null;
            const itemKey = getScrollItemKey(item);
            const bucket = scrollTypeStore[category];
            if (!bucket || typeof bucket !== 'object') return null;
            return bucket[itemKey] || null;
        }

        function setScrollStoreEntry(category, item, counts) {
            if (!scrollTypeStore || typeof scrollTypeStore !== 'object') {
                scrollTypeStore = {};
            }
            const itemKey = getScrollItemKey(item);
            if (!scrollTypeStore[category]) {
                scrollTypeStore[category] = {};
            }
            scrollTypeStore[category][itemKey] = {
                counts: normalizeScrollCounts(counts),
                updatedAt: Date.now()
            };
        }

        function loadScrollCountsFromLocalStorage(category, item) {
            const counts = getEmptyScrollCounts();
            const key = getScrollStorageKey(category, item, false);
            const legacyKey = getScrollStorageKey(category, item, true);
            const raw = localStorage.getItem(key) || (legacyKey !== key ? localStorage.getItem(legacyKey) : null);

            if (raw) {
                try {
                    const parsed = JSON.parse(raw);
                    if (parsed && typeof parsed === 'object' && parsed.counts) {
                        return { counts: normalizeScrollCounts(parsed.counts), hasStored: true };
                    }
                } catch (error) {
                    console.warn('Scroll counts parse failed:', error);
                }
            }

            return { counts, hasStored: false };
        }

        function loadScrollCountsFromProfile(category, item) {
            const entry = getScrollStoreEntry(category, item);
            if (entry && entry.counts) {
                return { counts: normalizeScrollCounts(entry.counts), hasStored: true };
            }
            return { counts: getEmptyScrollCounts(), hasStored: false };
        }

        function loadScrollCounts(category, item) {
            if (!category || !item) {
                return { counts: getEmptyScrollCounts(), hasStored: false };
            }

            if (inventoryStorageMode === 'character' && authApi) {
                const fromProfile = loadScrollCountsFromProfile(category, item);
                if (fromProfile.hasStored) return fromProfile;

                if (!inventoryMigrated) {
                    const legacy = loadScrollCountsFromLocalStorage(category, item);
                    if (legacy.hasStored) {
                        setScrollStoreEntry(category, item, legacy.counts);
                        return legacy;
                    }
                }
            }

            const local = loadScrollCountsFromLocalStorage(category, item);
            if (local.hasStored) return local;

            const seededTypeKey = getScrollTypeKey(item);
            const seededQty = Math.max(0, Number(item.quantity) || 0);
            if (seededTypeKey && seededQty > 0) {
                const counts = getEmptyScrollCounts();
                counts[seededTypeKey] = seededQty;
                saveScrollCounts(category, item, counts);
                return { counts, hasStored: true };
            }

            return { counts: getEmptyScrollCounts(), hasStored: false };
        }

        function saveScrollCounts(category, item, counts) {
            if (!category || !item) return;
            const payload = {
                counts: normalizeScrollCounts(counts),
                updatedAt: Date.now()
            };
            const key = getScrollStorageKey(category, item, false);
            localStorage.setItem(key, JSON.stringify(payload));

            if (inventoryStorageMode === 'character' && authApi) {
                setScrollStoreEntry(category, item, payload.counts);
                persistInventory();
            }
        }

        function sumScrollCounts(counts) {
            return Object.values(counts).reduce((sum, value) => sum + (Number(value) || 0), 0);
        }

        function syncScrollPanelHeights() {
            if (!scrollTypesPanel || !detailPanel || !scrollPanelHeader || !scrollPanelBody) return;
            const detailHeight = detailPanel.offsetHeight;
            if (!detailHeight) return;
            scrollTypesPanel.style.maxHeight = `${detailHeight}px`;
            const panelStyles = window.getComputedStyle(scrollTypesPanel);
            const paddingTop = parseFloat(panelStyles.paddingTop) || 0;
            const paddingBottom = parseFloat(panelStyles.paddingBottom) || 0;
            const headerHeight = scrollPanelHeader.offsetHeight;
            const maxBodyHeight = Math.max(160, detailHeight - headerHeight - paddingTop - paddingBottom);
            scrollPanelBody.style.maxHeight = `${maxBodyHeight}px`;
        }

        function setScrollPanelOpen(isOpen) {
            scrollPanelOpen = isOpen;
            if (inventoryContent) {
                inventoryContent.classList.toggle('scroll-panel-open', isOpen);
            }
            if (scrollTypesPanel) {
                scrollTypesPanel.classList.toggle('open', isOpen);
                scrollTypesPanel.setAttribute('aria-hidden', String(!isOpen));
            }
            if (scrollPanelToggleBtn) {
                scrollPanelToggleBtn.setAttribute('aria-expanded', String(isOpen));
            }
            if (!isOpen) {
                setScrollAddOpen(false);
            }
            syncScrollPanelHeights();
        }

        function setScrollPanelEmpty(message) {
            if (!scrollPanelTitle || !scrollPanelEmpty || !scrollPanelList) return;
            scrollPanelTitle.textContent = 'Types de parchemins';
            scrollPanelEmpty.textContent = message;
            scrollPanelEmpty.style.display = 'block';
            scrollPanelList.innerHTML = '';
            scrollPanelList.style.display = 'none';
        }

        function renderScrollPanelList(category, counts) {
            if (!scrollPanelTitle || !scrollPanelList || !scrollPanelEmpty) return;

            const titleText = category === 'eveil' ? '\u00c9veil' : 'Ascension';
            const visibleTypes = SCROLL_TYPES.filter((type) => (counts[type.key] || 0) > 0);
            scrollPanelTitle.textContent = titleText;

            if (visibleTypes.length === 0) {
                scrollPanelEmpty.textContent = 'Aucun type enregistré pour ce parchemin.';
                scrollPanelEmpty.style.display = 'block';
                scrollPanelList.innerHTML = '';
                scrollPanelList.style.display = 'none';
                return;
            }

            scrollPanelEmpty.style.display = 'none';
            scrollPanelList.style.display = 'grid';
            const rows = visibleTypes.map((type) => {
                const count = counts[type.key] || 0;
                const isSelected = type.key === selectedScrollTypeKey;
                return `
                    <div class="scroll-type-item${isSelected ? ' selected' : ''}" data-type-key="${type.key}">
                        <div class="scroll-type-row">
                            <span class="scroll-type-label">${escapeHtml(type.emoji)} ${escapeHtml(type.label)}</span>
                            <span class="scroll-type-count">x${count}</span>
                        </div>
                        ${isSelected ? `
                        <div class="scroll-type-controls">
                            <button type="button" class="scroll-type-qty-btn" data-action="minus">-</button>
                            <input type="number" min="1" value="1" class="scroll-type-qty-input">
                            <button type="button" class="scroll-type-qty-btn" data-action="plus">+</button>
                            <button type="button" class="scroll-type-add">Ajouter</button>
                            <button type="button" class="scroll-type-remove">Retirer</button>
                        </div>
                        ` : ''}
                    </div>
                `;
            }).join('');
            scrollPanelList.innerHTML = rows;
        }

        function setScrollAddOpen(isOpen) {
            scrollAddOpen = isOpen;
            if (!scrollPanelAdd || !scrollPanelAddBtn) return;
            scrollPanelAdd.classList.toggle('open', isOpen);
            scrollPanelAdd.setAttribute('aria-hidden', String(!isOpen));
            scrollPanelAddBtn.setAttribute('aria-expanded', String(isOpen));
            if (!isOpen && scrollTypeSearch) {
                scrollTypeSearch.value = '';
            }
        }

        function renderScrollSuggestions(filterText) {
            if (!scrollTypeSuggestions) return;
            const term = normalizeText(filterText);
            const filtered = SCROLL_TYPES.filter((type) => {
                if (!term) return true;
                if (normalizeText(type.label).includes(term)) return true;
                if (normalizeText(type.key).includes(term)) return true;
                return type.matchers?.some((matcher) => normalizeText(matcher).includes(term));
            });
            if (filtered.length === 0) {
                scrollTypeSuggestions.innerHTML = '<div class="scroll-suggestion-empty">Aucun type trouvé.</div>';
                return;
            }
            scrollTypeSuggestions.innerHTML = filtered.map((type) => {
                return `
                    <div class="scroll-suggestion-row" data-type-key="${type.key}">
                        <span class="scroll-suggestion-label">${escapeHtml(type.emoji)} ${escapeHtml(type.label)}</span>
                        <div class="scroll-suggestion-controls">
                            <input type="number" min="1" value="1" class="scroll-suggestion-qty">
                            <button type="button" class="scroll-suggestion-add">Ajouter</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function addScrollTypeCount(typeKey, qty) {
            if (!currentScrollItem || !scrollPanelCategory) return;
            const safeQty = Math.max(0, Math.floor(Number(qty) || 0));
            if (safeQty < 1) return;
            const { counts } = loadScrollCounts(scrollPanelCategory, currentScrollItem);
            counts[typeKey] = (counts[typeKey] || 0) + safeQty;
            saveScrollCounts(scrollPanelCategory, currentScrollItem, counts);
            const total = sumScrollCounts(counts);
            currentScrollItem.quantity = total;
            persistInventory();
            renderInventory();
            showItemDetail(currentScrollItem);
        }

        function removeScrollTypeCount(typeKey, qty) {
            if (!currentScrollItem || !scrollPanelCategory) return;
            const safeQty = Math.max(0, Math.floor(Number(qty) || 0));
            if (safeQty < 1) return;
            const { counts } = loadScrollCounts(scrollPanelCategory, currentScrollItem);
            const current = Number(counts[typeKey]) || 0;
            const next = Math.max(0, current - safeQty);
            counts[typeKey] = next;
            const total = sumScrollCounts(counts);

            if (total <= 0) {
                clearScrollCountsForItem(currentScrollItem);
                currentScrollItem.quantity = 0;
                const index = inventoryItems.findIndex((entry) => entry?.id === currentScrollItem?.id);
                if (index >= 0) {
                    inventoryItems.splice(index, 1);
                    if (selectedItemIndex === currentScrollItem?.id) {
                        selectedItemIndex = null;
                        showDetailPlaceholder();
                    }
                }
            } else {
                saveScrollCounts(scrollPanelCategory, currentScrollItem, counts);
                currentScrollItem.quantity = total;
            }

            persistInventory();
            renderInventory();
            if (selectedItemIndex === currentScrollItem?.id && total > 0) {
                showItemDetail(currentScrollItem);
            }
        }

        function updateScrollPanelForItem(item) {
            const category = getScrollCategory(item);
            scrollPanelCategory = category;
            currentScrollItem = item || null;
            const nextItemId = item?.id ?? null;
            if (nextItemId !== lastScrollItemId) {
                selectedScrollTypeKey = null;
                scrollAddOpen = true;
                lastScrollItemId = nextItemId;
            }
            if (!category) {
                if (scrollPanelToggleBtn) {
                    scrollPanelToggleBtn.disabled = true;
                    scrollPanelToggleBtn.setAttribute('aria-expanded', 'false');
                }
                if (scrollPanelAddBtn) {
                    scrollPanelAddBtn.disabled = true;
                }
                setScrollPanelOpen(false);
                setScrollPanelEmpty('Aucun type de parchemin disponible.');
                return;
            }

            if (scrollPanelToggleBtn) {
                scrollPanelToggleBtn.disabled = false;
            }
            if (scrollPanelAddBtn) {
                scrollPanelAddBtn.disabled = false;
            }

            const { counts, hasStored } = loadScrollCounts(category, item);
            if (hasStored) {
                const total = sumScrollCounts(counts);
                if (Number.isFinite(total) && item.quantity !== total) {
                    item.quantity = total;
                    persistInventory();
                }
            }

            renderScrollPanelList(category, counts);
            setScrollAddOpen(scrollAddOpen);
            renderScrollSuggestions(scrollTypeSearch?.value || '');
            syncScrollPanelHeights();
        }
        // =================================================================
        // RENDERING
        // =================================================================

        /**
         * Render the entire inventory grid
         * - Filters by current category
         * - Updates item count
         * - Shows empty state if needed
         * - Creates item cards
         */
        function renderInventory() {
            // Filter items by category + search
            let filtered = inventoryItems;
            const activeCategory = currentCategory === 'all' ? '' : currentCategory;
            if (filterItems) {
                filtered = filterItems(inventoryItems, {
                    category: activeCategory,
                    getCategory: (item) => item?.category,
                    query: currentSearchQuery,
                    fields: searchFields
                });
            } else {
                if (activeCategory) {
                    filtered = inventoryItems.filter(item => item.category === activeCategory);
                }
                if (currentSearchQuery) {
                    filtered = filtered.filter(item => {
                        const name = String(item?.name || '').toLowerCase();
                        const description = String(item?.description || '').toLowerCase();
                        const effect = String(item?.effect || '').toLowerCase();
                        return name.includes(currentSearchQuery) || description.includes(currentSearchQuery) || effect.includes(currentSearchQuery);
                    });
                }
            }

            if (selectedItemIndex !== null && !filtered.some(item => item.id === selectedItemIndex)) {
                selectedItemIndex = null;
                showDetailPlaceholder();
            }

            // Update count (shows currently filtered count)
            itemCountEl.textContent = `${filtered.length} objet${filtered.length > 1 ? 's' : ''}`;

            // Clear grid
            grid.innerHTML = '';

            // Show empty state if no items
            if (filtered.length === 0) {
                if (emptyStateMessage) {
                    emptyStateMessage.textContent = currentSearchQuery
                        ? 'Aucun objet trouv\u00e9 pour cette recherche.'
                        : 'Votre inventaire est vide dans cette cat\u00e9gorie';
                }
                grid.style.display = 'none';
                emptyState.style.display = 'flex';
                showDetailPlaceholder();
                return;
            }

            // Show grid
            grid.style.display = 'grid';
            emptyState.style.display = 'none';

            // Render each item
            filtered.forEach((item) => {
                const card = createItemCard(item);
                grid.appendChild(card);
            });
        }

        /**
         * Create an item card element
         * - Resolves image
         * - Shows quantity if > 1
         * - Attaches click handler
         */
        function createItemCard(item) {
            const card = document.createElement('div');
            card.className = 'inventory-item';
            card.dataset.itemId = item.id;
            if (item.id === selectedItemIndex) {
                card.classList.add('selected');
            }

            // Resolve image
            const imageSrc = resolveImage(item);
            const isCurrency = item?.isCurrency === true;

            const actionHtml = isCurrency
                ? ''
                : `
                    <div class="detail-actions">
                        <button class="item-action-use"
                                onclick="useItem(${item.id})"
                                title="Utiliser l'objet"
                                ${item.quantity < 1 ? 'disabled' : ''}
                                aria-label="Utiliser l'objet">
                            &#x2728;
                        </button>
                        <div class="action-stack">
                            <button class="item-action-delete"
                                    onclick="openDeleteModal(${item.id})"
                                    title="Supprimer l'objet"
                                    aria-label="Supprimer l'objet">
                                &#x1F5D1;&#xFE0F;
                            </button>
                            <button class="item-action-scroll-toggle"
                                    type="button"
                                    id="scrollTypesToggle"
                                    title="Types de parchemins"
                                    aria-label="Afficher les types de parchemins"
                                    aria-expanded="false"
                                    aria-controls="scrollTypesPanel">
                                &#x25BE;
                            </button>
                        </div>
                    </div>
                `;

            card.innerHTML = `
                <div class="item-image">
                    <img src="${escapeHtml(imageSrc)}"
                         alt="${escapeHtml(item.name)}"
                         decoding="async"
                         onerror="this.src='${PLACEHOLDER_IMAGE}'">
                </div>
                <div class="item-info">
                    <div class="item-name">${escapeHtml(item.name)}</div>
                    ${item.quantity > 1 ? `<div class="item-quantity">x${item.quantity}</div>` : ''}
                </div>
            `;

            // Click to select
            card.addEventListener('click', () => selectItem(item, card));

            return card;
        }

        // =================================================================
        // ITEM SELECTION & DETAILS
        // =================================================================

        /**
         * Select an item and show its details
         * - Removes previous selection
         * - Marks new selection
         * - Updates detail panel
         */
        function selectItem(item, cardElement) {
            // Remove previous selection
            document.querySelectorAll('.inventory-item').forEach(el => {
                el.classList.remove('selected');
            });

            // Mark as selected
            cardElement.classList.add('selected');
            selectedItemIndex = item.id;

            // Show details
            showItemDetail(item);
        }

        /**
         * Show item details in right panel
         * - Resolves image
         * - Shows all item properties
         */
        function showItemDetail(item) {
            const categoryLabels = {
                equipement: '&#x2694;&#xFE0F; &Eacute;quipement',
                consommable: '&#x1F9EA; Consommable',
                agricole: '&#x1F33E; Agricole'
            };

            const scrollCategory = getScrollCategory(item);
            const isCurrency = item?.isCurrency === true;
            if (scrollCategory) {
                const { counts, hasStored } = loadScrollCounts(scrollCategory, item);
                if (hasStored) {
                    const total = sumScrollCounts(counts);
                    if (Number.isFinite(total) && item.quantity !== total) {
                        item.quantity = total;
                        persistInventory();
                    }
                }
            }

            const actionHtml = isCurrency
                ? ''
                : `
                    <div class="detail-actions">
                        <button class="item-action-use"
                                onclick="useItem(${item.id})"
                                title="Utiliser l'objet"
                                ${item.quantity < 1 ? 'disabled' : ''}
                                aria-label="Utiliser l'objet">
                            &#x2728;
                        </button>
                        <div class="action-stack">
                            <button class="item-action-delete"
                                    onclick="openDeleteModal(${item.id})"
                                    title="Supprimer l'objet"
                                    aria-label="Supprimer l'objet">
                                &#x1F5D1;&#xFE0F;
                            </button>
                            <button class="item-action-scroll-toggle"
                                    type="button"
                                    id="scrollTypesToggle"
                                    title="Types de parchemins"
                                    aria-label="Afficher les types de parchemins"
                                    aria-expanded="false"
                                    aria-controls="scrollTypesPanel">
                                &#x25BE;
                            </button>
                        </div>
                    </div>
                `;

            const priceInfo = [];
            if (item.buyPrice) priceInfo.push(`Achat: ${item.buyPrice}`);
            if (item.sellPrice) priceInfo.push(`Vente: ${item.sellPrice}`);
            const priceText = priceInfo.length > 0 ? priceInfo.join(' | ') : 'Prix non défini';

            // Resolve image
            const imageSrc = resolveImage(item);

            detailPanel.innerHTML = `
                <div class="detail-header">
                    <div class="detail-title-wrapper">
                        <h2 class="detail-title">${escapeHtml(item.name)}</h2>
                        <span class="detail-category">${categoryLabels[item.category] || 'Autre'}</span>
                    </div>
                    ${actionHtml}
                </div>
                <div class="detail-image">
                    <img src="${escapeHtml(imageSrc)}"
                         alt="${escapeHtml(item.name)}"
                         decoding="async"
                         onerror="this.src='${PLACEHOLDER_IMAGE}'">
                </div>
                <div class="detail-body">
                    <div class="detail-section">
                        <span class="detail-label">Description</span>
                        <p class="detail-text">${escapeHtml(item.description || 'Aucune description disponible.')}</p>
                    </div>
                    ${item.effect ? `
                    <div class="detail-section">
                        <span class="detail-label">Effet</span>
                        <p class="detail-text detail-effect">${escapeHtml(item.effect)}</p>
                    </div>
                    ` : ''}
                    <div class="detail-section">
                        <span class="detail-label">Commerce</span>
                        <p class="detail-text">${escapeHtml(priceText)}</p>
                    </div>
                    ${(item.quantity > 1 || isCurrency) ? `
                    <div class="detail-section">
                        <span class="detail-label">Quantité</span>
                        <p class="detail-text">x${item.quantity}</p>
                    </div>
                    ` : ''}
                </div>
            `;
            scrollPanelToggleBtn = detailPanel.querySelector("#scrollTypesToggle");
            if (scrollPanelToggleBtn) {
                scrollPanelToggleBtn.addEventListener("click", () => {
                    if (scrollPanelToggleBtn.disabled) return;
                    setScrollPanelOpen(!scrollPanelOpen);
                    if (scrollPanelOpen && scrollPanelCategory && currentScrollItem) {
                        const { counts } = loadScrollCounts(scrollPanelCategory, currentScrollItem);
                        renderScrollPanelList(scrollPanelCategory, counts);
                    }
                });
            }

            setScrollPanelOpen(scrollPanelOpen);
            updateScrollPanelForItem(item);
        }

        function showDetailPlaceholder() {
            detailPanel.innerHTML = `
                <div class="detail-placeholder">
                    <div class="placeholder-icon">&#x1F446;</div>
                    <p>Sélectionnez un objet pour voir ses détails</p>
                </div>
            `;
            scrollPanelToggleBtn = null;
            scrollPanelCategory = null;
            selectedScrollTypeKey = null;
            lastScrollItemId = null;
            currentScrollItem = null;
            scrollAddOpen = false;
            if (scrollPanelAddBtn) {
                scrollPanelAddBtn.disabled = true;
            }
            setScrollAddOpen(false);
            setScrollPanelOpen(false);
            setScrollPanelEmpty("Aucun type de parchemin disponible.");
        }

        // =================================================================
        // ITEM ACTIONS (USE & DELETE)
        // =================================================================

        // Delete modal elements
        const deleteModal = document.getElementById('deleteModal');
        const deleteItemNameEl = document.getElementById('deleteItemName');
        const deleteQuantityInput = document.getElementById('deleteQuantityInput');
        const deleteQtyMinusBtn = document.getElementById('deleteQtyMinus');
        const deleteQtyPlusBtn = document.getElementById('deleteQtyPlus');
        const cancelDeleteBtn = document.getElementById('cancelDelete');
        const confirmDeleteBtn = document.getElementById('confirmDelete');

        let currentDeleteItemId = null;
        let currentDeleteItemMaxQty = 0;

        /**
         * Use an item - decreases quantity by 1
         * - Finds item by ID
         * - Decreases quantity by 1
         * - If quantity reaches 0, removes item
         * - Saves to localStorage
         * - Re-renders grid and details
         */
        function useItem(itemId) {
            const itemIndex = inventoryItems.findIndex(i => i.id === itemId);
            if (itemIndex === -1) return;

            const item = inventoryItems[itemIndex];
            if (item?.isCurrency) return;

            if (item.quantity < 1) {
                alert('Quantité insuffisante pour utiliser cet objet');
                return;
            }

            // Decrease quantity
            item.quantity -= 1;

            console.log(`Used ${item.name}. Quantity now: ${item.quantity}`);

            // If quantity reaches 0, remove item
            if (item.quantity <= 0) {
                resetScrollCountsAfterQtyChange(item);
                inventoryItems.splice(itemIndex, 1);
                selectedItemIndex = null;
                showDetailPlaceholder();
            } else {
                resetScrollCountsAfterQtyChange(item);
                // Refresh the detail view to update quantity display
                showItemDetail(item);
            }

            // Save to localStorage
            persistInventory();

            // Re-render grid
            renderInventory();
        }

        /**
         * Open delete confirmation modal
         * - Sets current item ID
         * - Shows item name
         * - Resets quantity input to 1
         * - Sets max quantity
         * - Opens modal
         */
        function openDeleteModal(itemId) {
            const item = inventoryItems.find(i => i.id === itemId);
            if (!item) return;
            if (item.isCurrency) return;

            currentDeleteItemId = itemId;
            currentDeleteItemMaxQty = item.quantity;

            // Update modal content
            deleteItemNameEl.textContent = item.name;
            deleteQuantityInput.value = 1;
            deleteQuantityInput.max = item.quantity;

            // Open modal
            deleteModal.classList.add('open');
        }

        /**
         * Close delete modal
         */
        function closeDeleteModal() {
            deleteModal.classList.remove('open');
            currentDeleteItemId = null;
            currentDeleteItemMaxQty = 0;
        }

        /**
         * Confirm deletion from modal
         * - Gets quantity to delete
         * - Updates item quantity or removes item
         * - Saves to localStorage
         * - Re-renders grid
         */
        function confirmDeletion() {
            if (!currentDeleteItemId) return;

            const qtyToDelete = parseInt(deleteQuantityInput.value) || 1;

            if (qtyToDelete < 1) {
                alert('La quantité doit être au moins 1');
                return;
            }

            if (qtyToDelete > currentDeleteItemMaxQty) {
                alert(`La quantité maximum est ${currentDeleteItemMaxQty}`);
                return;
            }

            const itemIndex = inventoryItems.findIndex(i => i.id === currentDeleteItemId);
            if (itemIndex === -1) return;

            const item = inventoryItems[itemIndex];

            // Update quantity or remove item
            if (qtyToDelete >= item.quantity) {
                // Remove item entirely
                resetScrollCountsAfterQtyChange(item);
                inventoryItems.splice(itemIndex, 1);
                selectedItemIndex = null;
                showDetailPlaceholder();
                console.log(`Deleted ${item.name} completely`);
            } else {
                // Decrease quantity
                item.quantity -= qtyToDelete;
                resetScrollCountsAfterQtyChange(item);
                showItemDetail(item);
                console.log(`Deleted ${qtyToDelete} of ${item.name}. Remaining: ${item.quantity}`);
            }

            // Save to localStorage
            persistInventory();

            // Close modal and re-render
            closeDeleteModal();
            renderInventory();
        }

        /**
         * Decrease delete quantity
         */
        function decreaseDeleteQuantity() {
            const current = parseInt(deleteQuantityInput.value) || 1;
            deleteQuantityInput.value = Math.max(1, current - 1);
        }

        /**
         * Increase delete quantity
         */
        function increaseDeleteQuantity() {
            const current = parseInt(deleteQuantityInput.value) || 1;
            const max = currentDeleteItemMaxQty;
            deleteQuantityInput.value = Math.min(max, current + 1);
        }

        // Attach event listeners for delete modal
        deleteQtyMinusBtn.addEventListener('click', decreaseDeleteQuantity);
        deleteQtyPlusBtn.addEventListener('click', increaseDeleteQuantity);
        cancelDeleteBtn.addEventListener('click', closeDeleteModal);
        confirmDeleteBtn.addEventListener('click', confirmDeletion);

        // Close modal when clicking outside
        deleteModal.addEventListener('click', (e) => {
            if (e.target === deleteModal) {
                closeDeleteModal();
            }
        });

        // Make functions globally accessible for onclick handlers
        window.useItem = useItem;
        window.openDeleteModal = openDeleteModal;

        // =================================================================
        // ITEM DELETION (OLD - KEPT FOR COMPATIBILITY)
        // =================================================================

        /**
         * Delete an item from inventory
         * - Removes from array
         * - Saves to localStorage
         * - Clears selection
         * - Re-renders grid
         */
        function deleteItem(itemId) {
            const itemIndex = inventoryItems.findIndex(i => i.id === itemId);
            if (itemIndex === -1) return;

            const itemName = inventoryItems[itemIndex].name;
            if (inventoryItems[itemIndex].isCurrency) return;

            // Confirm deletion
            if (!confirm(`Supprimer "${itemName}" de l'inventaire ?`)) {
                return;
            }

            // Remove from array
            resetScrollCountsAfterQtyChange(inventoryItems[itemIndex]);
            inventoryItems.splice(itemIndex, 1);

            // Save to localStorage
            persistInventory();

            // Clear selection
            selectedItemIndex = null;
            showDetailPlaceholder();

            // Re-render
            renderInventory();
        }

        // Make deleteItem globally accessible for onclick
        window.deleteItem = deleteItem;

        // =================================================================
        // UTILITIES
        // =================================================================

        /**
         * Escape HTML to prevent XSS
         */
        function escapeHtml(str) {
            if (!str) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }

        // =================================================================
        // ENTRY POINT
        // =================================================================

        /**
         * Initialize on page load
         */
        window.addEventListener('DOMContentLoaded', initInventory);
        window.addEventListener('astoria:character-updated', (event) => {
            const next = Number(event?.detail?.kaels);
            if (!Number.isFinite(next)) return;
            const currency = inventoryItems.find((item) => item?.isCurrency);
            if (!currency) return;
            currency.quantity = Math.max(0, Math.floor(next));
            renderInventory();
            if (selectedItemIndex === currency.id) {
                showItemDetail(currency);
            }
        });

        /**
         * Expose API for external use
         * - Can be called from codex.html or other pages
         */
        window.InventoryModule = {
            // Current state
            items: () => inventoryItems,

            // Core functions
            renderInventory,
            filterByCategory,

            // Add item from external page (e.g., codex.html)
            addItemFromExternal: (itemName, quantity = 1) => {
                const allItems = getAllItems();
                const sourceItem = allItems.find(i => i.name === itemName);
                const sourceIndex = allItems.indexOf(sourceItem);

                if (!sourceItem) {
                    console.error(`Item not found: ${itemName}`);
                    return false;
                }

                const existingItem = inventoryItems.find(i => i.sourceIndex === sourceIndex || i.name === itemName);

                if (existingItem) {
                    existingItem.quantity += quantity;
                    if (!Number.isFinite(Number(existingItem.sourceIndex)) && Number.isFinite(sourceIndex)) {
                        existingItem.sourceIndex = sourceIndex;
                    }
                } else {
                    inventoryItems.push({
                        id: nextItemId++,
                        sourceIndex,
                        ...sourceItem,
                        quantity: quantity
                    });
                }

                persistInventory();
                renderInventory();
                return true;
            },

            // Clear entire inventory (for testing)
            clearAll: () => {
                if (confirm('Effacer tout l\'inventaire ?')) {
                    inventoryItems = [];
                    nextItemId = 1;
                    persistInventory();
                    renderInventory();
                    console.log('Inventory cleared');
                }
            }
        };
        })();
    </script>
    <script src="js/sidebar.js"></script>
</body>
</html>


























