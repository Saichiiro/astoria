<!DOCTYPE html>



<html lang="fr">



<head>



    <meta charset="UTF-8">



    <meta name="viewport" content="width=device-width, initial-scale=1.0">



    <title>Inventaire - Astoria</title>



    <link rel="icon" type="image/x-icon" href="assets/images/ALICE_ACADEMIA.ico">



    <link rel="stylesheet" href="css/style.css">



    <link rel="stylesheet" href="css/inventaire.css">
    <link rel="stylesheet" href="css/cropper-controls.css?v=202602032">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cropperjs@1.6.1/dist/cropper.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/notyf@3.10.0/notyf.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/choices.js@10.2.0/public/assets/styles/choices.min.css">

    <style>
        /* Overrides pour aligner les slots sym√©triquement - FORC√â */
        .inventory-layout {
            align-items: start !important;
        }

        .inventory-sidebar {
            align-self: start !important;
            margin-top: 40px !important;
            position: sticky !important;
            top: 24px !important;
            display: block !important;
        }

        .inventory-main {
            margin-top: 0 !important;
            padding-top: 0 !important;
        }

        .character-card {
            margin-top: 0 !important;
            margin-bottom: 0 !important;
            min-height: 0 !important;
        }

        .character-showcase {
            display: grid;
            grid-template-columns: 56px 1fr 56px;
            grid-template-rows: 1fr auto auto;
            gap: 5px;
            padding: 6px;
            border-radius: var(--radius-xl);
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.85), rgba(237, 226, 238, 0.9));
            border: 2px dashed rgba(228, 132, 184, 0.35);
        }

        .equip-col {
            display: flex;
            flex-direction: column;
            gap: 5px;
            justify-content: center;
        }

        .equip-center {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            grid-row: 1;
            grid-column: 2;
        }

        .character-sprite {
            width: 100%;
            max-width: 200px;
            aspect-ratio: 230 / 320;
            background-image: url('assets/images/Silhouette.png');
            background-repeat: no-repeat;
            background-position: center;
            background-size: contain;
            border: none;
            box-shadow: none;
            cursor: pointer;
        }

        .character-upload-trigger {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 36px;
            height: 36px;
            border: none;
            border-radius: 999px;
            background: linear-gradient(135deg, #e91e63, #ff5d92);
            color: #fff;
            font-size: 1.3rem;
            line-height: 1;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 8px 16px rgba(233, 30, 99, 0.35);
            transition: transform 0.16s ease, box-shadow 0.16s ease;
            z-index: 2;
            transform: translate(-50%, -50%);
        }

        .character-upload-trigger:hover {
            transform: translate(-50%, calc(-50% - 1px));
            box-shadow: 0 10px 18px rgba(233, 30, 99, 0.32);
        }

        .character-upload-trigger:focus-visible {
            outline: 2px solid rgba(233, 30, 99, 0.6);
            outline-offset: 2px;
        }

        .equip-bottom {
            grid-column: 1 / -1;
            display: flex;
            gap: 5px;
            justify-content: center;
        }

        .character-rank {
            grid-column: 1 / -1;
            text-align: center;
            font-weight: 600;
            color: var(--inv-text);
            font-size: 0.9rem;
            white-space: nowrap;
        }

        .character-slot {
            width: 56px;
            height: 56px;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid rgba(238, 162, 201, 0.8);
            box-shadow: inset 0 0 8px rgba(216, 27, 96, 0.08);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            cursor: pointer;
            flex-shrink: 0;
            transition: border-color 0.16s ease, box-shadow 0.16s ease, transform 0.16s ease;
        }

        .character-slot:focus-visible {
            outline: 2px solid rgba(216, 27, 96, 0.65);
            outline-offset: 2px;
        }

        .character-slot.is-drop-target {
            border-color: rgba(216, 27, 96, 0.9);
            box-shadow: 0 0 0 3px rgba(216, 27, 96, 0.2);
            transform: scale(1.04);
        }

        .character-slot.has-item {
            border-color: rgba(216, 27, 96, 0.55);
            box-shadow: inset 0 0 10px rgba(216, 27, 96, 0.1), 0 4px 12px rgba(216, 27, 96, 0.12);
        }

        .character-slot-label {
            font-size: 0.6rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.02em;
            color: rgba(106, 43, 90, 0.85);
            text-align: center;
            line-height: 1.1;
            padding: 0 2px;
            user-select: none;
            pointer-events: none;
        }

        .character-slot-item-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            pointer-events: none;
        }

        /* =================================================================
           STATS SECTION
           ================================================================= */
        .character-stats {
            margin-top: 12px;
            padding: 12px;
            border-radius: var(--radius-lg);
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.9), rgba(243, 235, 240, 0.95));
            border: 2px solid rgba(238, 162, 201, 0.65);
            box-shadow: 0 4px 12px rgba(30, 20, 35, 0.08);
        }

        .stats-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(238, 162, 201, 0.35);
        }

        .stats-title {
            margin: 0;
            font-size: 0.85rem;
            font-weight: 700;
            color: #6a2b5a;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .stats-points {
            font-size: 0.75rem;
            font-weight: 600;
            color: #7a1242;
            background: rgba(255, 255, 255, 0.8);
            padding: 3px 8px;
            border-radius: 999px;
            border: 1px dashed rgba(216, 27, 96, 0.3);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .stat-box {
            padding: 10px;
            border-radius: var(--radius-md);
            background: rgba(255, 255, 255, 0.85);
            border: 1px solid rgba(238, 162, 201, 0.5);
        }

        .stat-box-title {
            margin: 0 0 8px 0;
            font-size: 0.7rem;
            font-weight: 700;
            color: #6a2b5a;
            text-transform: uppercase;
            letter-spacing: 0.02em;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
            font-size: 0.8rem;
            color: #5c3a4f;
            border-bottom: 1px dotted rgba(238, 162, 201, 0.25);
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .stat-icon {
            width: 16px;
            height: 16px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
        }

        .stat-value {
            font-weight: 700;
            color: #6a2b5a;
        }

        .stat-bar-container {
            grid-column: 1 / -1;
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 6px;
        }

        .stat-bar-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stat-bar-label {
            font-size: 0.7rem;
            font-weight: 600;
            color: #6a2b5a;
            min-width: 40px;
        }

        .stat-bar {
            flex: 1;
            height: 10px;
            background: rgba(238, 162, 201, 0.2);
            border-radius: 999px;
            overflow: hidden;
        }

        .stat-bar-fill {
            height: 100%;
            border-radius: 999px;
            transition: width 0.3s ease;
        }

        .stat-bar-fill--hp {
            background: linear-gradient(90deg, #e91e63, #ff5d92);
        }

        .stat-bar-fill--mana {
            background: linear-gradient(90deg, #2196f3, #64b5f6);
        }

        .stat-bar-value {
            font-size: 0.65rem;
            font-weight: 700;
            color: #5c3a4f;
            min-width: 70px;
            text-align: right;
        }

        @media (max-width: 400px) {
            .stats-grid {
                grid-template-columns: 1fr;
            }
        }

        .inventory-item--draggable {
            cursor: grab;
        }

        .inventory-item--draggable:active,
        .inventory-item--draggable.is-dragging {
            cursor: grabbing;
            opacity: 0.72;
        }

        .silhouette-cropper-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.56);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2147483000;
            padding: 20px;
        }

        .silhouette-cropper-backdrop.open {
            display: flex;
        }

        .silhouette-cropper-modal {
            width: min(760px, 96vw);
            max-height: 92vh;
            overflow: auto;
            background: #fff;
            border-radius: 16px;
            border: 2px solid rgba(216, 27, 96, 0.2);
            padding: 16px;
            box-shadow: 0 24px 48px rgba(0, 0, 0, 0.26);
        }

        .silhouette-cropper-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .silhouette-cropper-title {
            margin: 0;
            font-size: 1.05rem;
            color: var(--inv-text);
        }

        .silhouette-cropper-stage {
            width: 100%;
            min-height: 320px;
            max-height: 62vh;
            background: #f7f3f6;
            border-radius: 12px;
            overflow: hidden;
        }

        .silhouette-cropper-stage img {
            display: block;
            max-width: 100%;
        }

        .silhouette-cropper-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 12px;
        }

        .silhouette-cropper-controls input[type="range"] {
            flex: 1;
        }

        .silhouette-cropper-actions {
            margin-top: 12px;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
    </style>

</head>



<body class="min-h-screen">



            <!-- Main inventory wrapper -->



    <main class="inventory-wrapper" aria-labelledby="inventoryTitle">



                <!-- Header with title and back button -->



        <header class="page-header">
            <a href="codex.html" class="page-back" title="Retour au codex">‚Üê Retour</a>
            <div class="page-header-main">
                <div class="page-title-block">
                    <h1 class="page-title" id="inventoryTitle">Inventaire</h1>
                </div>
                <div class="character-summary" aria-label="R√©sum√© du personnage">



                <div class="character-avatar-wrapper">



                    <div class="character-avatar character-avatar--clickable" role="button" tabindex="0" aria-haspopup="true" aria-label="Changer de personnage">



                        <img class="character-avatar-img" id="characterSummaryAvatar" alt="Avatar" hidden>



                        <div class="character-avatar-circle" id="characterSummaryInitial" hidden></div>



                    </div>



                    <div class="character-dropdown" hidden aria-label="S√©lectionner un personnage"></div>



                </div>



                <div class="character-summary-text">



                    <a class="character-name" id="characterSummaryName" href="profil.html">Nom du personnage</a>



                    <span class="character-tagline" id="characterSummaryTagline">Classe / Role / Surnom</span>



                    <div class="character-summary-meta">



                        <span class="stats-badge" id="characterKaelsBadge" hidden>0 kaels</span>



                        <div class="character-souls" id="characterSouls" hidden>



                            <span class="soul-count" title="&Acirc;mes consommation"><span class="soul-icon">üî•</span><span id="soulConsoValue">0</span></span>



                            <span class="soul-count" title="&Acirc;mes progression"><span class="soul-icon">‚≠ê</span><span id="soulProgValue">0</span></span>



                        </div>



                    </div>



                </div>
            </div>
        </header>

        <div class="inventory-layout">
            <aside class="inventory-sidebar" aria-label="Equipement du personnage">
                <div class="character-card" aria-label="Personnage">
                    <div class="character-showcase">
                        <!-- Left column (5) -->
                        <div class="equip-col equip-left">
                            <div class="character-slot" data-slot-key="head" data-slot-label="Casque" role="button" tabindex="0" aria-label="Slot Casque">
                                <span class="character-slot-label">Casque</span>
                            </div>
                            <div class="character-slot" data-slot-key="amulet" data-slot-label="Collier" role="button" tabindex="0" aria-label="Slot Collier">
                                <span class="character-slot-label">Collier</span>
                            </div>
                            <div class="character-slot" data-slot-key="chest" data-slot-label="Plastron" role="button" tabindex="0" aria-label="Slot Plastron">
                                <span class="character-slot-label">Plastron</span>
                            </div>
                            <div class="character-slot" data-slot-key="ring1" data-slot-label="Anneau" role="button" tabindex="0" aria-label="Slot Anneau">
                                <span class="character-slot-label">Anneau</span>
                            </div>
                            <div class="character-slot" data-slot-key="ring2" data-slot-label="Anneau" role="button" tabindex="0" aria-label="Slot Anneau">
                                <span class="character-slot-label">Anneau</span>
                            </div>
                        </div>

                        <!-- Center: character -->
                        <div class="equip-center">
                            <div class="character-sprite" aria-hidden="true"></div>
                            <button type="button" class="character-upload-trigger tw-press" id="silhouetteUploadTrigger" aria-label="Importer une silhouette">+</button>
                        </div>

                        <!-- Right column (5) -->
                        <div class="equip-col equip-right">
                            <div class="character-slot" data-slot-key="cape" data-slot-label="Cape" role="button" tabindex="0" aria-label="Slot Cape">
                                <span class="character-slot-label">Cape</span>
                            </div>
                            <div class="character-slot" data-slot-key="shoulders" data-slot-label="Epaulettes" role="button" tabindex="0" aria-label="Slot Epaulettes">
                                <span class="character-slot-label">Epaulettes</span>
                            </div>
                            <div class="character-slot" data-slot-key="belt" data-slot-label="Ceinture" role="button" tabindex="0" aria-label="Slot Ceinture">
                                <span class="character-slot-label">Ceinture</span>
                            </div>
                            <div class="character-slot" data-slot-key="gloves" data-slot-label="Gantelets" role="button" tabindex="0" aria-label="Slot Gantelets">
                                <span class="character-slot-label">Gantelets</span>
                            </div>
                            <div class="character-slot" data-slot-key="boots" data-slot-label="Bottes" role="button" tabindex="0" aria-label="Slot Bottes">
                                <span class="character-slot-label">Bottes</span>
                            </div>
                        </div>

                        <!-- Bottom row (5) -->
                        <div class="equip-bottom">
                            <div class="character-slot" data-slot-key="artifact" data-slot-label="Artefact" role="button" tabindex="0" aria-label="Slot Artefact">
                                <span class="character-slot-label">Artefact</span>
                            </div>
                            <div class="character-slot" data-slot-key="weapon" data-slot-label="Arme" role="button" tabindex="0" aria-label="Slot Arme">
                                <span class="character-slot-label">Arme</span>
                            </div>
                            <div class="character-slot" data-slot-key="offhand" data-slot-label="Arme √† deux mains" role="button" tabindex="0" aria-label="Slot Arme √† deux mains">
                                <span class="character-slot-label">Arme 2 mains</span>
                            </div>
                            <div class="character-slot" data-slot-key="mount" data-slot-label="Monture" role="button" tabindex="0" aria-label="Slot Monture">
                                <span class="character-slot-label">Monture</span>
                            </div>
                            <div class="character-slot" data-slot-key="companion" data-slot-label="Familier" role="button" tabindex="0" aria-label="Slot Familier">
                                <span class="character-slot-label">Familier</span>
                            </div>
                        </div>

                        <div class="character-rank">Rang : 3</div>
                    </div>

                    <!-- Stats Section -->
                    <div class="character-stats" id="characterStats">
                        <div class="stats-header">
                            <h3 class="stats-title">Attributs</h3>
                            <span class="stats-points" id="statsPointsAvailable">0 pts dispo</span>
                        </div>

                        <!-- HP / Mana bars -->
                        <div class="stat-bar-container">
                            <div class="stat-bar-row">
                                <span class="stat-bar-label">HP</span>
                                <div class="stat-bar">
                                    <div class="stat-bar-fill stat-bar-fill--hp" id="hpBar" style="width: 75%;"></div>
                                </div>
                                <span class="stat-bar-value" id="hpValue">750 / 1000</span>
                            </div>
                            <div class="stat-bar-row">
                                <span class="stat-bar-label">Mana</span>
                                <div class="stat-bar">
                                    <div class="stat-bar-fill stat-bar-fill--mana" id="manaBar" style="width: 60%;"></div>
                                </div>
                                <span class="stat-bar-value" id="manaValue">600 / 1000</span>
                            </div>
                        </div>

                        <div class="stats-grid">
                            <div class="stat-box">
                                <h4 class="stat-box-title">Principal</h4>
                                <div class="stat-row">
                                    <span class="stat-label"><span class="stat-icon">&#9876;</span> Attaque</span>
                                    <span class="stat-value" id="statAttack">150</span>
                                </div>
                                <div class="stat-row">
                                    <span class="stat-label"><span class="stat-icon">&#128737;</span> Defense</span>
                                    <span class="stat-value" id="statDefense">120</span>
                                </div>
                                <div class="stat-row">
                                    <span class="stat-label"><span class="stat-icon">&#10024;</span> Magie</span>
                                    <span class="stat-value" id="statMagic">85</span>
                                </div>
                            </div>
                            <div class="stat-box">
                                <h4 class="stat-box-title">Secondaire</h4>
                                <div class="stat-row">
                                    <span class="stat-label"><span class="stat-icon">&#9889;</span> Vitesse</span>
                                    <span class="stat-value" id="statSpeed">45</span>
                                </div>
                                <div class="stat-row">
                                    <span class="stat-label"><span class="stat-icon">&#127919;</span> Critique</span>
                                    <span class="stat-value" id="statCrit">12%</span>
                                </div>
                                <div class="stat-row">
                                    <span class="stat-label"><span class="stat-icon">&#128170;</span> Force</span>
                                    <span class="stat-value" id="statStrength">60</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </aside>

            <section class="inventory-main">
                <div class="inventory-actions">
                    <span id="itemCount" class="inventory-info">0 objets</span>
                    <button class="add-item-btn tw-press" id="openAddPanel" title="Ajouter un objet">
                        <span class="add-icon">+</span>
                        <span class="add-label">Ajouter</span>
                    </button>
                </div>

                <!-- Category filter bar + search -->
                <div class="inventory-toolbar">



            <nav class="inventory-categories" aria-label="Cat&eacute;gories d'inventaire">



                <button class="category-btn active tw-press" data-category="all">



                    <span class="category-icon">&#x1F4E6;</span>



                    <span class="category-label">Tous</span>



                </button>



                <button class="category-btn tw-press" data-category="agricole">



                    <span class="category-icon">&#x1F33E;</span>



                    <span class="category-label">Agricole</span>



                </button>



                <button class="category-btn tw-press" data-category="consommable">



                    <span class="category-icon">&#x1F9EA;</span>



                    <span class="category-label">Consommables</span>



                </button>



                <button class="category-btn tw-press" data-category="equipement">



                    <span class="category-icon">&#x2694;&#xFE0F;</span>



                    <span class="category-label">&Eacute;quipements</span>



                </button>



                <button class="category-btn tw-press" data-category="materiau">



                    <span class="category-icon">&#x2692;&#xFE0F;</span>



                    <span class="category-label">Mat√©riaux</span>



                </button>



                <button class="category-btn tw-press" data-category="quete">



                    <span class="category-icon">&#x2728;</span>



                    <span class="category-label">Qu√™tes</span>



                </button>



            </nav>



            <div class="inventory-search" id="inventorySearch">



                <button type="button" class="inventory-search-toggle tw-press" id="inventorySearchToggle" aria-label="Rechercher" aria-expanded="false">



                    <span class="inventory-search-icon">&#x1F50D;</span>



                </button>



                <input



                    type="search"



                    id="inventorySearchInput"



                    class="inventory-search-input tw-input"



                    placeholder="Rechercher un objet..."



                    aria-label="Rechercher un objet"



                >



                <button type="button" class="inventory-search-clear tw-press" id="inventorySearchClear" aria-label="Effacer la recherche" hidden>x</button>



                <div class="recent-searches-dropdown inventory-search-history" id="inventorySearchHistory"></div>



            </div>



                </div>

                <!-- Main content area: grid + details -->
                <div class="inventory-content">



            <!-- Items grid (left side) -->



                        <div class="inventory-grid-container">



                <div class="inventory-grid" id="inventoryGrid">



                    <!-- Items will be rendered here by JS -->



                </div>



                <div class="empty-inventory is-hidden" id="emptyState">



                    <div class="empty-state-icon">&#x1F4E6;</div>



                    <div class="empty-state-title">Aucun objet</div>



                    <div class="empty-state-message">Votre inventaire est vide dans cette cat√©gorie</div>



                </div>



            </div>



            <!-- Item detail panel (right side) -->



                        <div class="inventory-detail" id="itemDetail">



                <div class="detail-placeholder">



                    <div class="placeholder-icon">&#x1F446;</div>



                    <p>S√©lectionnez un objet pour voir ses d√©tails</p>



                </div>



                <!-- Details will be rendered here when item is selected -->



            </div>



            <!-- Scroll types panel (right-most side) -->



            <aside class="scroll-types-panel" id="scrollTypesPanel" aria-hidden="true">



                <div class="scroll-panel-header">



                    <h3 id="scrollPanelTitle">Types de parchemins</h3>



                    <button class="scroll-panel-add-btn tw-press" id="scrollPanelAddBtn" type="button" title="Ajouter des parchemins" aria-label="Ajouter des parchemins" aria-expanded="false" aria-controls="scrollPanelAdd" disabled>+</button>



                </div>



                <div class="scroll-panel-body" id="scrollPanelBody">



                    <div class="scroll-panel-add" id="scrollPanelAdd" aria-hidden="true">



                        <div class="scroll-add-search">



                            <input type="text" id="scrollTypeSearch" class="tw-input" placeholder="Rechercher un type">



                        </div>



                        <div class="scroll-suggestions" id="scrollTypeSuggestions"></div>



                    </div>



                    <p class="scroll-panel-empty" id="scrollPanelEmpty">Aucun type de parchemin disponible.</p>



                    <div class="scroll-panel-list" id="scrollPanelList"></div>



                </div>



            </aside>



                </div>
            </section>
        </div>



    </main>



    <!-- Add item panel (slide-in from right) -->



    <div class="add-panel" id="addPanel">



        <div class="add-panel-inner">



            <div class="add-panel-header">



                <h2>Ajouter un objet</h2>



                <button class="panel-close-btn tw-press" id="closeAddPanel">&times;</button>



            </div>



            <div class="add-panel-body">



                <!-- Item selector (from existing database) -->



                <div class="form-group">



                    <label for="itemSelect">Objet *</label>



                    <select id="itemSelect" class="tw-input" required>



                        <option value="">-- S√©lectionner un objet --</option>



                        <!-- Options populated by JS from inventoryData -->



                    </select>



                </div>



                                <!-- Category selector -->



                <div class="form-group">



                    <label for="categorySelect">Cat√©gorie *</label>



                    <select id="categorySelect" class="tw-input" required>



                        <option value="all">&#x1F4E6; Toutes cat√©gories</option>



                        <option value="agricole">&#x1F33E; Agricole</option>



                        <option value="consommable">&#x1F9EA; Consommable</option>



                        <option value="equipement">&#x2694;&#xFE0F; &Eacute;quipement</option>



                        <option value="materiau">&#x2692;&#xFE0F; Mat√©riaux</option>



                        <option value="quete">&#x2728; Qu√™tes</option>



                    </select>



                </div>



                <!-- Quantity selector -->



                <div class="form-group">



                    <label for="quantityInput">Quantit√© *</label>



                    <div class="quantity-control">



                        <button type="button" class="qty-btn tw-press" id="qtyMinus">-</button>



                        <input type="number" id="quantityInput" class="tw-input" min="1" value="1">



                        <button type="button" class="qty-btn tw-press" id="qtyPlus">+</button>



                    </div>



                </div>



                <!-- Item preview (shows selected item details) -->



                <div id="itemPreview" class="item-preview">



                    <div class="form-group">



                        <label>Aper√ßu</label>



                        <div class="item-preview-card">



                            <img id="previewImage" class="item-preview-image" src="" alt="" decoding="async">



                            <div>



                                <div class="item-preview-name" id="previewName"></div>



                                <div class="item-preview-description" id="previewDescription"></div>



                            </div>



                        </div>



                    </div>



                </div>



            </div>



            <div class="add-panel-footer">



                <button type="button" class="btn-secondary tw-press" id="cancelAdd">Annuler</button>



                <button type="button" class="btn-primary tw-press" id="confirmAdd">Ajouter</button>



            </div>



        </div>



    </div>



    <!-- Delete confirmation modal -->



    <div class="delete-modal-overlay" id="deleteModal">



        <div class="delete-modal">



            <div class="delete-modal-header">



                <h3>Supprimer l'objet</h3>



            </div>



            <div class="delete-modal-body">



                <p>Combien d'unit√©s de <span class="delete-modal-item-name" id="deleteItemName"></span> voulez-vous supprimer ?</p>



                <div class="form-group">



                    <label for="deleteQuantityInput">Quantit√© √† supprimer</label>



                    <div class="quantity-control">



                        <button type="button" class="qty-btn tw-press" id="deleteQtyMinus">-</button>



                        <input type="number" id="deleteQuantityInput" class="tw-input" min="1" value="1">



                        <button type="button" class="qty-btn tw-press" id="deleteQtyPlus">+</button>



                    </div>



                </div>



            </div>



            <div class="delete-modal-footer">



                <button type="button" class="btn-secondary tw-press" id="cancelDelete">Annuler</button>



                <button type="button" class="btn-danger tw-press" id="confirmDelete">Supprimer</button>



            </div>



        </div>



    </div>



    <input type="file" id="silhouetteUploadInput" accept="image/*" hidden>

    <div class="silhouette-cropper-backdrop" id="silhouetteCropperBackdrop" aria-hidden="true">
        <div class="silhouette-cropper-modal" role="dialog" aria-modal="true" aria-labelledby="silhouetteCropperTitle">
            <div class="silhouette-cropper-header">
                <h3 class="silhouette-cropper-title" id="silhouetteCropperTitle">Importer la silhouette du personnage</h3>
                <button type="button" class="btn-secondary tw-press" id="silhouetteCropperClose">Fermer</button>
            </div>
            <div class="silhouette-cropper-stage">
                <img id="silhouetteCropperImage" alt="Apercu silhouette">
            </div>
            <div class="silhouette-cropper-controls">
                <!-- Aspect Ratio Controls -->
                <div class="cropper-control-group">
                    <label>Format</label>
                    <div class="cropper-button-group">
                        <button type="button" class="cropper-btn cropper-aspect-btn" data-ratio="1" title="Carr√© 1:1">‚ñ° Carr√©</button>
                        <button type="button" class="cropper-btn cropper-aspect-btn active" data-ratio="0.71875" title="Portrait 230:320">‚ñØ Portrait</button>
                        <button type="button" class="cropper-btn cropper-aspect-btn" data-ratio="1.7778" title="Paysage 16:9">‚ñ≠ Paysage</button>
                    </div>
                </div>

                <!-- Rotation Controls -->
                <div class="cropper-control-group">
                    <label>Rotation</label>
                    <div class="cropper-button-group">
                        <button type="button" class="cropper-btn tw-press" id="silhouetteCropperRotateLeft" title="Rotation -90¬∞">‚Ü∫ -90¬∞</button>
                        <button type="button" class="cropper-btn tw-press" id="silhouetteCropperRotateRight" title="Rotation +90¬∞">‚Üª +90¬∞</button>
                        <button type="button" class="cropper-btn tw-press" id="silhouetteCropperRotate180" title="Rotation 180¬∞">‚Üª 180¬∞</button>
                    </div>
                </div>

                <!-- Flip Controls -->
                <div class="cropper-control-group">
                    <label>Miroir</label>
                    <div class="cropper-button-group">
                        <button type="button" class="cropper-btn tw-press" id="silhouetteCropperFlipX" title="Miroir horizontal">‚Üî Horizontal</button>
                        <button type="button" class="cropper-btn tw-press" id="silhouetteCropperFlipY" title="Miroir vertical">‚Üï Vertical</button>
                    </div>
                </div>

                <!-- Zoom Controls -->
                <div class="cropper-control-group">
                    <label for="silhouetteCropperZoom">Zoom</label>
                    <div class="cropper-zoom-group">
                        <button type="button" class="cropper-btn tw-press" id="silhouetteCropperZoomOut" title="Zoom -">‚àí</button>
                        <input type="range" id="silhouetteCropperZoom" min="0.2" max="3" step="0.01" value="1">
                        <button type="button" class="cropper-btn tw-press" id="silhouetteCropperZoomIn" title="Zoom +">+</button>
                    </div>
                </div>

                <!-- Reset Button -->
                <div class="cropper-control-group">
                    <button type="button" class="cropper-btn cropper-btn-secondary tw-press" id="silhouetteCropperReset" title="R√©initialiser">‚Ü∫ R√©initialiser</button>
                </div>

                <span>Ratio personnage 230x320 (portrait)</span>
            </div>
            <div class="silhouette-cropper-actions">
                <button type="button" class="btn-secondary tw-press" id="silhouetteCropperCancel">Annuler</button>
                <button type="button" class="btn-danger tw-press" id="silhouetteCropperConfirm">Appliquer</button>
            </div>
        </div>
    </div>

    <!-- Load shared data -->



    <script src="js/image-helpers.js"></script>



    <script src="js/data.js"></script>



    <script src="js/item-modifiers.js"></script>



    <script src="js/ui/list-helpers.js"></script>



    <script src="js/ui/search-history.js"></script>



    <script src="js/ui/searchbar.js"></script>

    <!-- External Libraries (CDN) - MUST LOAD FIRST -->
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.9/dist/purify.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cropperjs@1.6.1/dist/cropper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/notyf@3.10.0/notyf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/body-scroll-lock@4.0.0-beta.0/lib/bodyScrollLock.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/localforage@1.10.0/dist/localforage.min.js"></script>
    
    
    
    <!-- Choices.js for select dropdowns (~18KB) -->
    <script src="https://cdn.jsdelivr.net/npm/choices.js@10.2.0/public/assets/scripts/choices.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>

    <!-- Library Wrappers (Astoria) - MUST LOAD BEFORE APP SCRIPTS -->
    <script src="js/components/toast-manager.js"></script>
    <script src="js/components/storage-manager.js"></script>
    <script src="js/components/modal-manager.js"></script>
    <script src="js/components/uploader-cropper.js"></script>
    <script src="js/components/drag-drop-manager.js"></script>
    <script src="js/utils/sanitize.js"></script>

    <!-- App Scripts -->
    <script type="module" src="js/ui/app-shell.js"></script>



    <script type="module">



        import { initCharacterSummary } from './js/ui/character-summary.js';



        // Initialize character summary with kaels and dropdown



        document.addEventListener('DOMContentLoaded', async () => {



            await initCharacterSummary({ enableDropdown: true, showKaels: true });



        });



    </script>



    <!-- Inventory-specific JS -->



    <script>



        (function () {



        /**



         * ========================================================================



         * INVENTORY MODULE - EMPTY BY DEFAULT WITH ADD PANEL



         * ========================================================================



         *



         * TEMPORARY IMPLEMENTATION FOR TESTING:



         * - Inventory starts EMPTY on first load



         * - Items stored in localStorage for persistence (testing only)



         * - Items are added via "+" panel which selects from existing database



         * - All item data (name, description, image) comes from data.js



         *



         * FUTURE INTEGRATION:



         * - Replace localStorage with real backend API



         * - Load inventory from server instead of localStorage



         * - Connect to global item management system



         * ========================================================================



         */



        // =================================================================



        // CONFIGURATION



        // =================================================================



        /**



         * IMAGE CONFIGURATION & PLACEHOLDER



         * D√©l√©gu√©s au helper global image-helpers.js



         */



        const INVENTORY_IMAGE_HELPERS = window.astoriaImageHelpers || {};



        const PLACEHOLDER_IMAGE = INVENTORY_IMAGE_HELPERS.smallPlaceholder;



        const DEFAULT_SCROLL_TYPES = [
            { key: 'feu', emoji: String.fromCodePoint(0x1F525), label: 'Feu', matchers: ['feu'] },
            { key: 'eau', emoji: String.fromCodePoint(0x1F4A7), label: 'Eau', matchers: ['eau'] },
            { key: 'vent', emoji: String.fromCodePoint(0x1F32C), label: 'Vent', matchers: ['vent'] },
            { key: 'terre', emoji: String.fromCodePoint(0x1FAA8), label: 'Terre', matchers: ['terre'] },
            { key: 'nature', emoji: String.fromCodePoint(0x1F331), label: 'Nature', matchers: ['nature'] },
            { key: 'roche', emoji: String.fromCodePoint(0x1FAA8), label: 'Roche', matchers: ['roche'] },
            { key: 'metaux', emoji: String.fromCodePoint(0x1F9F2), label: 'M\u00e9taux', matchers: ['metaux', 'm\u00e9taux'] },
            { key: 'cryo', emoji: String.fromCodePoint(0x1F9CA), label: 'Cryo (glace)', matchers: ['cryo', 'glace'] },
            { key: 'foudre', emoji: String.fromCodePoint(0x26A1), label: 'Foudre', matchers: ['foudre'] },
            { key: 'lumiere', emoji: String.fromCodePoint(0x1F31F), label: 'Lumi\u00e8re', matchers: ['lumiere', 'lumi\u00e8re'] },
            { key: 'tenebres', emoji: String.fromCodePoint(0x1F319), label: 'T\u00e9n\u00e8bres', matchers: ['tenebres', 't\u00e9n\u00e8bres'] },
            { key: 'cristal', emoji: String.fromCodePoint(0x1F48E), label: 'Cristal', matchers: ['cristal'] }
        ];



        const SCROLL_TYPES = Array.isArray(window.astoriaScrollTypes) && window.astoriaScrollTypes.length



            ? window.astoriaScrollTypes



            : DEFAULT_SCROLL_TYPES;



        if (!Array.isArray(window.astoriaScrollTypes) || window.astoriaScrollTypes.length < DEFAULT_SCROLL_TYPES.length) {



            window.astoriaScrollTypes = DEFAULT_SCROLL_TYPES;



        }



        const SCROLL_TYPES_META_KEY = 'astoria_scroll_types_meta';



        const SCROLL_TYPE_FALLBACK_EMOJI = String.fromCodePoint(0x2728);



        function formatScrollTypeLabel(key) {



            const raw = String(key || '').replace(/[-_]+/g, ' ').trim();



            if (!raw) return '';



            return raw.charAt(0).toUpperCase() + raw.slice(1);



        }



        function getScrollTypeMetaByKey(key) {



            if (!key) return null;



            if (typeof window.astoriaGetScrollTypeMeta === 'function') {



                const entry = window.astoriaGetScrollTypeMeta(key);



                if (entry) return entry;



            }



            const normalized = normalizeText(key);



            const existing = SCROLL_TYPES.find((type) => normalizeText(type.key) === normalized);



            if (existing) return existing;



            return {



                key: String(key),



                label: formatScrollTypeLabel(key),



                emoji: SCROLL_TYPE_FALLBACK_EMOJI,



                matchers: []



            };



        }



        function persistScrollTypeMeta() {



            try {



                const payload = SCROLL_TYPES.map((type) => ({



                    key: type.key,



                    label: type.label,



                    emoji: type.emoji,



                    matchers: Array.isArray(type.matchers) ? type.matchers : []



                }));



                const next = JSON.stringify(payload);



                const current = localStorage.getItem(SCROLL_TYPES_META_KEY);



                if (current !== next) {



                    localStorage.setItem(SCROLL_TYPES_META_KEY, next);



                }



                window.astoriaScrollTypes = payload;



            } catch (error) {



                console.warn('Failed to persist scroll type metadata:', error);



            }



        }



        persistScrollTypeMeta();



        // =================================================================



        // =================================================================



        // STATE



        // =================================================================



        let currentCategory = 'all';



        let currentSearchQuery = '';



        let selectedItemIndex = null;



        let inventoryItems = []; // Starts EMPTY



        let nextItemId = 1; // Auto-increment ID for new items



        let inventoryStorageMode = 'local'; // 'local' | 'character'



        let authApi = null;



        let inventoryApi = null;



        let pendingProfileSaveTimer = null;



        let scrollPanelOpen = false;



        let scrollPanelCategory = null;



        let scrollPanelToggleBtn = null;



        let scrollAddOpen = false;



        let currentScrollItem = null;



        let selectedScrollTypeKey = null;



        let lastScrollItemId = null;



        let scrollTypeStore = {};



        let inventoryMigrated = false;

        const EQUIPPED_SLOTS_STORAGE_KEY = 'astoriaInventoryEquippedSlots';
        const EQUIPMENT_SLOT_DEFS = [
            { key: 'head', label: 'Casque' },
            { key: 'cape', label: 'Cape' },
            { key: 'shoulders', label: 'Epaulettes' },
            { key: 'amulet', label: 'Collier' },
            { key: 'chest', label: 'Plastron' },
            { key: 'gloves', label: 'Gantelets' },
            { key: 'belt', label: 'Ceinture' },
            { key: 'ring1', label: 'Anneau' },
            { key: 'boots', label: 'Bottes' },
            { key: 'ring2', label: 'Anneau' },
            { key: 'artifact', label: 'Artefact' },
            { key: 'weapon', label: 'Arme' },
            { key: 'offhand', label: 'Arme \u00e0 deux mains' },
            { key: 'companion', label: 'Familier' },
            { key: 'mount', label: 'Monture' }
        ];

        let equippedSlots = {};
        let equipmentSlotsBound = false;
        let draggedEquipmentItemId = null;

        let draggedEquipmentSlotKey = null;



        // DOM REFERENCES



        // =================================================================



        const grid = document.getElementById('inventoryGrid');



        const detailPanel = document.getElementById('itemDetail');



        const emptyState = document.getElementById('emptyState');



        const emptyStateMessage = emptyState ? emptyState.querySelector('.empty-state-message') : null;



        const itemCountEl = document.getElementById('itemCount');



        const categoryButtons = document.querySelectorAll('.category-btn');



        const searchRoot = document.getElementById('inventorySearch');



        const searchInput = document.getElementById('inventorySearchInput');



        const searchToggle = document.getElementById('inventorySearchToggle');



        const searchClear = document.getElementById('inventorySearchClear');



        const searchHistoryDropdown = document.getElementById('inventorySearchHistory');



        const inventoryContent = document.querySelector('.inventory-content');



        const scrollTypesPanel = document.getElementById('scrollTypesPanel');



        const scrollPanelTitle = document.getElementById('scrollPanelTitle');



        const scrollPanelBody = document.getElementById('scrollPanelBody');



        const scrollPanelHeader = document.querySelector('.scroll-panel-header');



        const scrollPanelAddBtn = document.getElementById('scrollPanelAddBtn');



        const scrollPanelEmpty = document.getElementById('scrollPanelEmpty');



        const scrollPanelList = document.getElementById('scrollPanelList');



        const scrollPanelAdd = document.getElementById('scrollPanelAdd');



        const scrollTypeSearch = document.getElementById('scrollTypeSearch');



        const scrollTypeSuggestions = document.getElementById('scrollTypeSuggestions');



        // Add panel elements



        const addPanel = document.getElementById('addPanel');



        const openAddBtn = document.getElementById('openAddPanel');



        const closeAddBtn = document.getElementById('closeAddPanel');



        const cancelAddBtn = document.getElementById('cancelAdd');



        const confirmAddBtn = document.getElementById('confirmAdd');



        const itemSelect = document.getElementById('itemSelect');



        const categorySelect = document.getElementById('categorySelect');



        const quantityInput = document.getElementById('quantityInput');



        const qtyMinusBtn = document.getElementById('qtyMinus');



        const qtyPlusBtn = document.getElementById('qtyPlus');



        const itemPreview = document.getElementById('itemPreview');



        const previewImage = document.getElementById('previewImage');



        const previewName = document.getElementById('previewName');



        const previewDescription = document.getElementById('previewDescription');



        const inventoryWrapper = document.querySelector('.inventory-wrapper');



        let inventoryAccessAllowed = true;



        const listHelpers = window.astoriaListHelpers || {};

        const characterSpriteEl = document.querySelector('.character-sprite');
        const silhouetteUploadTrigger = document.getElementById('silhouetteUploadTrigger');
        const silhouetteUploadInput = document.getElementById('silhouetteUploadInput');
        const silhouetteCropperBackdrop = document.getElementById('silhouetteCropperBackdrop');
        const silhouetteCropperImage = document.getElementById('silhouetteCropperImage');
        const silhouetteCropperZoom = document.getElementById('silhouetteCropperZoom');
        const silhouetteCropperZoomIn = document.getElementById('silhouetteCropperZoomIn');
        const silhouetteCropperZoomOut = document.getElementById('silhouetteCropperZoomOut');
        const silhouetteCropperRotateLeft = document.getElementById('silhouetteCropperRotateLeft');
        const silhouetteCropperRotateRight = document.getElementById('silhouetteCropperRotateRight');
        const silhouetteCropperRotate180 = document.getElementById('silhouetteCropperRotate180');
        const silhouetteCropperFlipX = document.getElementById('silhouetteCropperFlipX');
        const silhouetteCropperFlipY = document.getElementById('silhouetteCropperFlipY');
        const silhouetteCropperReset = document.getElementById('silhouetteCropperReset');
        const silhouetteCropperClose = document.getElementById('silhouetteCropperClose');
        const silhouetteCropperCancel = document.getElementById('silhouetteCropperCancel');
        const silhouetteCropperConfirm = document.getElementById('silhouetteCropperConfirm');
        const SILHOUETTE_STORAGE_KEY = 'astoriaInventoryCharacterSilhouette';
        const DEFAULT_SILHOUETTE = 'assets/images/Silhouette.png';
        const SILHOUETTE_RATIO = 230 / 320;
        // Silhouette cropper now uses uploaderCropper wrapper



        const filterItems = listHelpers.filterItems;



        const searchFields = [



            (item) => item?.name,



            (item) => item?.description,



            (item) => item?.effect,



            (item) => {



                const tools = window.astoriaItemModifiers;



                if (!tools?.toBadgeModel || !tools?.getModifiers) return '';



                return tools.toBadgeModel(tools.getModifiers(item)).map((badge) => badge.label).join(' ');



            }



        ];



        const searchHistory = window.astoriaSearchHistory



            ? window.astoriaSearchHistory.createSearchHistory({



                storageKey: 'astoriaInventoryRecentSearches',



                maxItems: 4



            })



            : null;



        const INVENTORY_SYNC_KEY = 'astoria_inventory_sync';



        function broadcastInventorySync(reason = 'update') {



            try {



                const character = authApi?.getActiveCharacter?.();



                if (!character?.id) return;



                const payload = {



                    characterId: String(character.id),



                    reason,



                    ts: Date.now()



                };



                localStorage.setItem(INVENTORY_SYNC_KEY, JSON.stringify(payload));



            } catch (error) {



                console.warn('Inventory sync broadcast failed:', error);



            }



        }



        async function handleInventorySync(payload) {



            if (!payload) return;



            if (inventoryStorageMode !== 'character' || !authApi) return;



            const character = authApi.getActiveCharacter?.();



            if (!character?.id) return;



            if (String(payload.characterId) !== String(character.id)) return;



            await loadInventory();



            syncCurrencyItem();



            renderInventory();



        }



        window.addEventListener('storage', (event) => {



            if (event.key !== INVENTORY_SYNC_KEY || !event.newValue) return;



            try {



                const payload = JSON.parse(event.newValue);



                void handleInventorySync(payload);



            } catch {



                // ignore invalid payloads



            }



        });



        // =================================================================



        // INITIALIZATION



        // =================================================================



        /**



         * Initialize inventory - EMPTY BY DEFAULT



         * - Loads from localStorage ONLY (if present)



         * - Otherwise displays empty inventory



         * - Renders the UI



         */



        async function initInventory() {



            console.log('Initializing inventory...');



            await hydrateItemsFromDb();



            await initInventoryStorage();



            initSilhouetteUploader();



            if (!inventoryAccessAllowed) {



                renderInventoryAccessDenied();



                return;



            }



            await loadInventory();



            syncCurrencyItem();



            await loadCharacterSilhouette();



            initEquipmentSlots();



            // Render



            renderInventory();



            // Note: Item selector is populated when add panel opens



        }



        // =================================================================



        // ITEM DATABASE ACCESS



        // =================================================================



        /**



         * TEMPORARY FUNCTION: Get all available items from data.js



         *



         * This function accesses our existing central item database (inventoryData).



         * In production, this would query the real backend database.



         *



         * @returns {Array} All available items from the game database



         */



        function getAllItems() {



            if (typeof inventoryData === 'undefined' || !inventoryData) {



                console.warn('inventoryData not found in data.js');



                return [];



            }



            return inventoryData.filter((item) =>



                !isLocalItemTombstoned(item) && !isItemDisabled(item)



            );



        }



        function safeJson(value) {



            if (!value) return {};



            if (typeof value === 'object') return value;



            if (typeof value === 'string') {



                try {



                    return JSON.parse(value);



                } catch {



                    return {};



                }



            }



            return {};



        }



        function normalizeItemName(name) {



            return String(name || '')



                .normalize('NFD')



                .replace(/[\u0300-\u036f]/g, '')



                .replace(/[^a-zA-Z0-9]+/g, '')



                .toLowerCase();



        }



        const ITEM_TOMBSTONES_KEY = 'astoriaItemTombstones';



        let disabledItemNames = new Set();



        function getItemTombstones() {



            try {



                const raw = localStorage.getItem(ITEM_TOMBSTONES_KEY);



                const parsed = raw ? JSON.parse(raw) : [];



                return Array.isArray(parsed) ? parsed : [];



            } catch {



                return [];



            }



        }



        function isLocalItemTombstoned(item) {



            if (!item || item._dbId || item.source === 'db') return false;



            const key = normalizeItemName(item.name || item.nom || '');



            if (!key) return false;



            const tombstones = getItemTombstones();



            return tombstones.includes(key);



        }



        function isItemDisabled(item) {



            const key = normalizeItemName(item?.name || item?.nom || '');



            if (!key) return false;



            return disabledItemNames.has(key);



        }



        function resolveItemByKey(itemKey, itemIndex) {



            const allItems = getAllItems();



            const numericIndex = Number.isFinite(Number(itemIndex)) ? Number(itemIndex) : null;



            if (numericIndex != null && numericIndex >= 0 && allItems[numericIndex]) {



                return { item: allItems[numericIndex], index: numericIndex };



            }



            const numericKey = Number.isFinite(Number(itemKey)) ? Number(itemKey) : null;



            if (numericKey != null && numericKey >= 0 && allItems[numericKey]) {



                return { item: allItems[numericKey], index: numericKey };



            }



            const normalizedKey = normalizeItemName(itemKey);



            if (normalizedKey) {



                const byName = allItems.findIndex((entry) =>



                    normalizeItemName(entry?.name || entry?.nom || '') === normalizedKey



                );



                if (byName >= 0) {



                    return { item: allItems[byName], index: byName };



                }



            }



            return { item: null, index: -1 };



        }



        async function reconcileInventoryRows(characterId, rows) {



            if (!characterId || !inventoryApi?.setInventoryItem || !Array.isArray(rows)) return rows;



            const canonicalByName = new Map();



            rows.forEach((row) => {



                const key = normalizeItemName(row?.item_key);



                if (!key) return;



                if (!canonicalByName.has(key)) canonicalByName.set(key, row);



            });



            const updates = [];



            const nextRows = [];



            rows.forEach((row) => {



                const resolved = resolveItemByKey(row?.item_key, row?.item_index);



                const canonicalKey = resolved?.item?.name ? String(resolved.item.name) : '';



                const canonicalNorm = normalizeItemName(canonicalKey);



                const rowNorm = normalizeItemName(row?.item_key);



                if (!canonicalKey || !canonicalNorm || !rowNorm || canonicalNorm === rowNorm) {



                    nextRows.push(row);



                    return;



                }



                const canonicalRow = canonicalByName.get(canonicalNorm);



                if (canonicalRow) {



                    // Canonical row already exists, drop the legacy key row.



                    updates.push(inventoryApi.setInventoryItem(characterId, String(row.item_key), row?.item_index, 0));



                    return;



                }



                // Migrate legacy key to canonical name.



                updates.push(inventoryApi.setInventoryItem(characterId, String(row.item_key), row?.item_index, 0));



                updates.push(inventoryApi.setInventoryItem(characterId, canonicalKey, resolved.index, row?.qty));



                nextRows.push({



                    ...row,



                    item_key: canonicalKey,



                    item_index: Number.isFinite(resolved.index) && resolved.index >= 0 ? resolved.index : row?.item_index



                });



            });



            if (updates.length) {



                try {



                    await Promise.allSettled(updates);



                } catch (error) {



                    console.warn('Inventory reconcile failed:', error);



                }



            }



            return nextRows;



        }



        function mapDbItem(row) {



            const images = safeJson(row.images);



            const modifiers = safeJson(row.modifiers);



            const primary = images.primary || images.url || row.image || row.image_url || '';



            const priceText = row.price_kaels ? `${row.price_kaels} kaels` : '';



            return {



                _dbId: row.id,



                source: 'db',



                name: row.name || '',



                description: row.description || '',



                effect: row.effect || '',



                category: row.category || '',



                buyPrice: priceText,



                sellPrice: priceText,



                modifiers: Array.isArray(modifiers) ? modifiers : [],



                image: primary,



                images: images,



                equipment_slot: row.equipment_slot || ''



            };



        }



        async function hydrateItemsFromDb() {



            if (!Array.isArray(window.inventoryData)) return;



            try {



                const itemsApi = await import('./js/api/items-service.js');



                if (!itemsApi?.getAllItems) return;



                const rows = await itemsApi.getAllItems();



                if (!Array.isArray(rows) || rows.length === 0) return;



                disabledItemNames = new Set(



                    rows



                        .filter((row) => row && row.enabled === false)



                        .map((row) => normalizeItemName(row.name || row.nom || ''))



                        .filter(Boolean)



                );



                const mapped = rows



                    .filter((row) => row && row.enabled !== false)



                    .map(mapDbItem);



                const nameToIndex = new Map();



                window.inventoryData.forEach((item, idx) => {



                    const key = normalizeItemName(item?.name || item?.nom || '');



                    if (key) nameToIndex.set(key, idx);



                });



                mapped.forEach((item) => {



                    if (!item || !item.name) return;



                    const key = normalizeItemName(item.name);



                    const existingIndex = nameToIndex.get(key);



                    if (existingIndex != null) {



                        window.inventoryData[existingIndex] = {



                            ...window.inventoryData[existingIndex],



                            ...item



                        };



                        return;



                    }



                    window.inventoryData.push(item);



                    nameToIndex.set(key, window.inventoryData.length - 1);



                });



            } catch (error) {



                console.warn('Inventory DB items load failed:', error);



            }



        }



        /**



         * Populate the item selector dropdown with items from database



         * Filters by selected category for clarity



         */



        function populateItemSelector() {



            const allItems = getAllItems();



            const selectedCategory = categorySelect.value;



            // Clear existing options (except the first placeholder)



            itemSelect.innerHTML = '<option value="">-- S√©lectionner un objet --</option>';



            // Filter items by category if not "all"



            const filteredItems = selectedCategory === 'all'



                ? allItems



                : allItems.filter(item => item.category === selectedCategory);



            // Add filtered items as options



            filteredItems.forEach((item, index) => {



                // Use the original index from allItems for referencing



                const originalIndex = allItems.indexOf(item);



                const option = document.createElement('option');



                option.value = originalIndex; // Use original index to reference the item



                option.textContent = item.name;



                option.dataset.category = item.category;



                itemSelect.appendChild(option);



            });



        }



        // =================================================================



        // PERSISTENCE - LocalStorage (TEMPORARY)



        // =================================================================



        function hydrateInventoryFromCompact(items) {



            const allItems = getAllItems();



            inventoryItems = [];



            nextItemId = 1;



            if (!Array.isArray(items)) return;



            items.forEach((entry) => {



                const idx = Number(entry?.idx);



                const qty = Number(entry?.qty);



                if (!Number.isFinite(idx) || !Number.isFinite(qty) || qty <= 0) return;



                const sourceItem = allItems[idx];



                if (!sourceItem) return;



                inventoryItems.push({



                    id: nextItemId++,



                    sourceIndex: idx,



                    name: sourceItem.name,



                    category: sourceItem.category,



                    image: sourceItem.image,



                    description: sourceItem.description,



                    effect: sourceItem.effect,



                    buyPrice: sourceItem.buyPrice,



                    sellPrice: sourceItem.sellPrice,



                    quantity: Math.floor(qty)



                });



            });



        }



        function hydrateInventoryFromRows(rows) {



            const allItems = getAllItems();



            inventoryItems = [];



            nextItemId = 1;



            const missingRows = [];



            if (!Array.isArray(rows)) return;



            rows.forEach((row) => {



                const qty = Number(row?.qty);



                if (!Number.isFinite(qty) || qty <= 0) return;

                // Skip Kaels - currency is managed separately via character.kaels
                const itemKey = String(row?.item_key || '').toLowerCase();
                if (itemKey === 'kaels') return;



                const resolved = resolveItemByKey(row?.item_key, row?.item_index);



                const sourceItem = resolved.item;



                if (!sourceItem) {



                    missingRows.push(row);



                    return;



                }



                inventoryItems.push({



                    id: nextItemId++,



                    sourceIndex: resolved.index,



                    ...sourceItem,



                    quantity: Math.floor(qty)



                });



            });



            return missingRows;



        }



        function buildInventoryRows(characterId) {



            return inventoryItems



                .map((item) => {



                    if (item?.isCurrency) return null;



                    const qty = Math.floor(Number(item?.quantity) || 0);



                    if (qty <= 0) return null;



                    const resolved = resolveItemByKey(item?.name, item?.sourceIndex);



                    const idx = resolved.index;



                    const itemKey = item?.name || resolved.item?.name;



                    if (!itemKey) return null;



                    return {



                        character_id: characterId,



                        item_key: String(itemKey),



                        item_index: Number.isFinite(idx) && idx >= 0 ? idx : null,



                        qty



                    };



                })



                .filter(Boolean);



        }



        function serializeInventoryForProfile() {



            const totalQty = inventoryItems.reduce((sum, item) => {



                if (item?.isCurrency) return sum;



                const qty = Math.floor(Number(item?.quantity) || 0);



                return sum + (Number.isFinite(qty) ? qty : 0);



            }, 0);



            return {



                version: 1,



                migrated: true,



                itemCount: inventoryItems.filter((item) => !item?.isCurrency).length,



                totalQty,



                scrollTypes: normalizeScrollTypeStore(scrollTypeStore),



                equippedSlots: serializeEquippedSlots()



            };



        }



        function syncCurrencyItem() {



            if (!authApi || typeof authApi.getActiveCharacter !== 'function') return;



            const character = authApi.getActiveCharacter();



            const rawKaels = Number(character?.kaels ?? 0);



            if (!Number.isFinite(rawKaels)) return;



            const kaels = Math.max(0, Math.floor(rawKaels));



            const existing = inventoryItems.find((item) => item?.isCurrency);



            if (existing) {



                existing.quantity = kaels;



                return;



            }



            inventoryItems.unshift({



                id: 0,



                name: 'Kaels',



                category: 'consommable',



                description: "Monnaie officielle d'Astoria.",



                effect: 'Utilisee pour acheter et vendre.',



                quantity: kaels,



                isCurrency: true



            });



        }



        function applyCharacterSilhouette(src) {



            if (!characterSpriteEl) return;



            const safeSrc = src && String(src).trim() ? String(src).trim() : DEFAULT_SILHOUETTE;



            characterSpriteEl.style.backgroundImage = `url('${safeSrc}')`;



            // Hide + button when a custom silhouette is loaded
            const uploadBtn = document.getElementById('silhouetteUploadTrigger');
            if (uploadBtn) {
                const isCustom = safeSrc !== DEFAULT_SILHOUETTE;
                uploadBtn.style.display = isCustom ? 'none' : '';
            }



        }



        function readStoredSilhouette() {



            try {



                const raw = localStorage.getItem(SILHOUETTE_STORAGE_KEY);



                return raw ? String(raw) : '';



            } catch {



                return '';



            }



        }



        async function persistSilhouette(src) {



            const safeSrc = src && String(src).trim() ? String(src).trim() : '';



            try {



                if (safeSrc) {



                    localStorage.setItem(SILHOUETTE_STORAGE_KEY, safeSrc);



                } else {



                    localStorage.removeItem(SILHOUETTE_STORAGE_KEY);



                }



            } catch {}



            if (inventoryStorageMode !== 'character' || !authApi?.getActiveCharacter || !authApi?.updateCharacter) {



                return;



            }



            const character = authApi.getActiveCharacter();



            if (!character?.id) return;



            const currentProfileData = character.profile_data || {};



            const inventoryData = { ...(currentProfileData.inventory || {}) };



            if (safeSrc) {



                inventoryData.characterSilhouette = safeSrc;



            } else {



                delete inventoryData.characterSilhouette;



            }



            const nextProfileData = {



                ...currentProfileData,



                inventory: inventoryData



            };



            try {



                await authApi.updateCharacter(character.id, { profile_data: nextProfileData });



            } catch (error) {



                console.warn('Silhouette save error:', error);



            }



        }



        async function loadCharacterSilhouette() {



            let nextSrc = '';



            if (inventoryStorageMode === 'character' && authApi?.getActiveCharacter) {



                const character = authApi.getActiveCharacter();



                nextSrc = String(character?.profile_data?.inventory?.characterSilhouette || '');



            }



            if (!nextSrc) {



                nextSrc = readStoredSilhouette();



            }



            applyCharacterSilhouette(nextSrc || DEFAULT_SILHOUETTE);



        }



        function closeSilhouetteCropper() {
            if (silhouetteCropperBackdrop) {
                modalManager.close(silhouetteCropperBackdrop);
            }
            uploaderCropper.destroy();
            if (silhouetteUploadInput) silhouetteUploadInput.value = '';
        }



        function openSilhouetteCropper(file) {
            if (!file || !silhouetteCropperBackdrop || !silhouetteCropperImage || !window.Cropper) {
                toastManager.warning('Recadrage indisponible');
                return;
            }

            // Use uploaderCropper wrapper for consistency
            const success = uploaderCropper.open(file, {
                imageElement: silhouetteCropperImage,
                aspectRatio: SILHOUETTE_RATIO, // 230:320
                outputWidth: 460,
                outputHeight: 640,
                quality: 0.95,
                enableRotate: true,
                enableZoom: true
            });

            if (!success) {
                toastManager.error('Impossible d\'ouvrir le recadrage');
                return;
            }

            // Show modal
            modalManager.open(silhouetteCropperBackdrop, {
                closeOnBackdropClick: false,
                closeOnEsc: true,
                openClass: 'open'
            });

            // Wire up cropper controls
            if (silhouetteCropperZoom) {
                silhouetteCropperZoom.oninput = () => {
                    if (uploaderCropper.cropper) {
                        uploaderCropper.cropper.zoomTo(Number(silhouetteCropperZoom.value));
                    }
                };
            }

            if (silhouetteCropperZoomIn) {
                silhouetteCropperZoomIn.onclick = () => uploaderCropper.zoomIn();
            }

            if (silhouetteCropperZoomOut) {
                silhouetteCropperZoomOut.onclick = () => uploaderCropper.zoomOut();
            }

            if (silhouetteCropperRotateLeft) {
                silhouetteCropperRotateLeft.onclick = () => uploaderCropper.rotate(-90);
            }

            if (silhouetteCropperRotateRight) {
                silhouetteCropperRotateRight.onclick = () => uploaderCropper.rotate(90);
            }

            if (silhouetteCropperRotate180) {
                silhouetteCropperRotate180.onclick = () => uploaderCropper.rotate(180);
            }

            if (silhouetteCropperFlipX) {
                silhouetteCropperFlipX.onclick = () => uploaderCropper.flipX();
            }

            if (silhouetteCropperFlipY) {
                silhouetteCropperFlipY.onclick = () => uploaderCropper.flipY();
            }

            if (silhouetteCropperReset) {
                silhouetteCropperReset.onclick = () => uploaderCropper.reset();
            }

            // Wire up aspect ratio buttons
            const aspectButtons = silhouetteCropperBackdrop?.querySelectorAll('.cropper-aspect-btn');
            aspectButtons?.forEach(btn => {
                btn.onclick = () => {
                    const ratio = parseFloat(btn.dataset.ratio);
                    if (uploaderCropper.cropper && Number.isFinite(ratio)) {
                        uploaderCropper.cropper.setAspectRatio(ratio);
                        // Update active state
                        aspectButtons.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                    }
                };
            });
        }



        function initSilhouetteUploader() {



            if (!characterSpriteEl || !silhouetteUploadInput) return;
            if (silhouetteCropperBackdrop && silhouetteCropperBackdrop.parentElement !== document.body) {
                document.body.appendChild(silhouetteCropperBackdrop);
            }



            characterSpriteEl.title = "Cliquer pour importer une silhouette (cropper).";



            characterSpriteEl.setAttribute('aria-label', 'Importer une silhouette de personnage');
            characterSpriteEl.setAttribute('role', 'button');
            characterSpriteEl.setAttribute('tabindex', '0');
            if (silhouetteUploadTrigger) {
                silhouetteUploadTrigger.title = "Importer une silhouette";
            }

            const triggerSilhouetteUpload = () => {
                silhouetteUploadInput.click();
            };



            characterSpriteEl.addEventListener('click', () => {



                triggerSilhouetteUpload();



            });

            characterSpriteEl.addEventListener('keydown', (event) => {
                if (event.key !== 'Enter' && event.key !== ' ') return;
                event.preventDefault();
                triggerSilhouetteUpload();
            });

            silhouetteUploadTrigger?.addEventListener('click', () => {
                triggerSilhouetteUpload();
            });



            silhouetteUploadInput.addEventListener('change', () => {



                const file = silhouetteUploadInput.files?.[0];



                if (!file) return;



                if (!window.Cropper) {



                    alert('Cropper indisponible pour le moment.');



                    silhouetteUploadInput.value = '';



                    return;



                }



                openSilhouetteCropper(file);



                silhouetteUploadInput.value = '';



            });



            silhouetteCropperClose?.addEventListener('click', closeSilhouetteCropper);



            silhouetteCropperCancel?.addEventListener('click', closeSilhouetteCropper);



            silhouetteCropperBackdrop?.addEventListener('click', (event) => {



                if (event.target === silhouetteCropperBackdrop) closeSilhouetteCropper();



            });

            document.addEventListener('keydown', (event) => {
                if (event.key !== 'Escape') return;
                if (!silhouetteCropperBackdrop?.classList.contains('open')) return;
                event.preventDefault();
                closeSilhouetteCropper();
            });



            // Zoom handled in openSilhouetteCropper via uploaderCropper

            silhouetteCropperConfirm?.addEventListener('click', async () => {
                if (!uploaderCropper.cropper) return;

                const result = await uploaderCropper.confirm();
                if (!result || !result.blob) {
                    toastManager.error('Recadrage impossible');
                    return;
                }

                // Convert blob to data URL
                const reader = new FileReader();
                reader.onload = async () => {
                    const dataUrl = String(reader.result || '');
                    if (dataUrl) {
                        applyCharacterSilhouette(dataUrl);
                        await persistSilhouette(dataUrl);
                        toastManager.success('Silhouette mise √† jour');
                    }
                };
                reader.readAsDataURL(result.blob);

                closeSilhouetteCropper();
            });



        }



        function renderInventoryAccessDenied() {



            if (!inventoryWrapper) return;



            inventoryWrapper.innerHTML = `



                <div class="empty-state">



                    <div class="empty-state-icon">LOCK</div>



                    <div class="empty-state-title">Acces restreint</div>



                    <div class="empty-state-message">



                        Seul le proprietaire du personnage ou un administrateur peut consulter cet inventaire.



                    </div>



                </div>



            `;



        }



        async function initInventoryStorage() {



            inventoryStorageMode = 'local';



            authApi = null;



            inventoryApi = null;



            try {



                authApi = await import('./js/auth.js');



                inventoryApi = await import('./js/api/inventory-service.js');



                const user = authApi.getCurrentUser?.();



                const character = authApi.getActiveCharacter?.();



                const isAdmin = authApi.isAdmin?.() || false;



                console.log('[Inventory Storage] Init:', { user: !!user, character: !!character, characterId: character?.id, isAdmin });

                if (user && character && character.id) {



                    inventoryStorageMode = 'character';



                    console.log('[Inventory Storage] Mode set to CHARACTER - items will save to database');



                    if (character.user_id && !isAdmin && character.user_id !== user.id) {



                        inventoryAccessAllowed = false;



                    }



                } else {



                    console.warn('[Inventory Storage] Mode remains LOCAL - items will only save to localStorage', {
                        reason: !user ? 'No user logged in' : !character ? 'No active character' : 'No character ID'
                    });



                }



            } catch (error) {



                // No server / module blocked / auth module unavailable => stay in local mode



                console.error('[Inventory Storage] Failed to initialize - staying in LOCAL mode:', error);



                inventoryStorageMode = 'local';



                authApi = null;



                inventoryApi = null;



            }



        }



        async function loadInventory() {



            if (inventoryStorageMode !== 'character' || !authApi || !inventoryApi) {



                loadFromLocalStorage();



                return;



            }



            const character = authApi.getActiveCharacter?.();



            const payload = character?.profile_data?.inventory;



            const hasMigrated = payload?.migrated === true;



            inventoryMigrated = hasMigrated;



            if (payload && payload.scrollTypes && typeof payload.scrollTypes === 'object') {



                scrollTypeStore = payload.scrollTypes;



            } else {



                scrollTypeStore = {};



            }



            equippedSlots = normalizeEquippedSlots(payload?.equippedSlots || payload?.equipped || {});



            try {



                const rows = await inventoryApi.getInventoryRows?.(character?.id);



                if (Array.isArray(rows)) {



                    if (rows.length > 0) {



                        const normalizedRows = await reconcileInventoryRows(character?.id, rows);



                        const missingRows = hydrateInventoryFromRows(normalizedRows) || [];



                        console.log(`Loaded ${inventoryItems.length} items from character_inventory`);



                        if (missingRows.length) {



                            await cleanupMissingInventoryRows(character?.id, missingRows);



                        }



                        return;



                    }



                    if (!hasMigrated) {



                        loadFromLocalStorage();



                        if (inventoryItems.length > 0) {



                            console.log('Migrating local inventory to character_inventory...');



                            await saveInventoryToBackend();



                            return;



                        }



                    } else {



                        try {



                            localStorage.removeItem('astoriaInventory');



                        } catch {



                            // ignore cleanup failures



                        }



                    }



                    hydrateInventoryFromRows([]);



                    return;



                }



            } catch (error) {



                console.warn('Inventory load error (character_inventory):', error);



            }



            hydrateInventoryFromRows([]);



        }



        async function cleanupMissingInventoryRows(characterId, rows) {



            if (!characterId || !inventoryApi?.setInventoryItem) return;



            const deletions = rows.map((row) => {



                const key = row?.item_key ?? row?.item_index;



                if (key == null) return null;



                return inventoryApi.setInventoryItem(characterId, String(key), row?.item_index, 0);



            }).filter(Boolean);



            if (!deletions.length) return;



            try {



                await Promise.allSettled(deletions);



                console.log(`Removed ${deletions.length} missing inventory items.`);



            } catch (error) {



                console.warn('Failed to cleanup missing inventory items:', error);



            }



        }



        async function saveInventoryToCharacterProfile() {



            if (inventoryStorageMode !== 'character' || !authApi) return;



            const character = authApi.getActiveCharacter?.();



            if (!character || !character.id) return;



            const currentProfileData = character.profile_data || {};



            const nextProfileData = {



                ...currentProfileData,



                inventory: serializeInventoryForProfile(),



            };



            try {



                const res = await authApi.updateCharacter?.(character.id, { profile_data: nextProfileData });



                if (!res || !res.success) {



                    console.warn('Inventory save failed (profile_data).');



                }



            } catch (error) {



                console.warn('Inventory save error (profile_data):', error);



            }



        }



        async function saveInventoryToBackend() {



            if (inventoryStorageMode !== 'character' || !authApi || !inventoryApi) {
                console.warn('[Inventory Storage] Backend save skipped:', {
                    mode: inventoryStorageMode,
                    hasAuth: !!authApi,
                    hasInventoryApi: !!inventoryApi
                });
                return;
            }



            const character = authApi.getActiveCharacter?.();



            if (!character || !character.id) {
                console.warn('[Inventory Storage] Backend save skipped: No character or character ID');
                return;
            }



            const rows = buildInventoryRows(character.id);

            console.log(`[Inventory Storage] Saving ${rows.length} items to database for character ${character.id}...`);



            let saved = false;



            try {



                await inventoryApi.replaceInventoryRows?.(character.id, rows);



                saved = true;

                console.log('[Inventory Storage] ‚úÖ Successfully saved inventory to database!');



            } catch (error) {



                console.warn('Inventory save error (character_inventory):', error);



            }

            // Save kaels to character.kaels field
            const currencyItem = inventoryItems.find(item => item?.isCurrency);
            if (currencyItem && Number.isFinite(currencyItem.quantity)) {
                const kaels = Math.max(0, Math.floor(currencyItem.quantity));
                const currentKaels = Number(character?.kaels ?? 0);

                if (kaels !== currentKaels) {
                    try {
                        await authApi.updateCharacter?.(character.id, { kaels });
                        console.log(`[Inventory Storage] ‚úÖ Updated kaels: ${currentKaels} ‚Üí ${kaels}`);
                    } catch (error) {
                        console.warn('Kaels save error:', error);
                    }
                }
            }



            await saveInventoryToCharacterProfile();



            if (saved) {



                broadcastInventorySync('save');



            }



        }



        function persistInventory() {



            // Always keep local backup (handy for offline testing)



            saveToLocalStorage();



            if (inventoryStorageMode !== 'character') {
                console.log('[Inventory Storage] Persist: Mode is LOCAL - only saved to localStorage (not database)');
                return;
            }

            console.log('[Inventory Storage] Persist: Scheduling database save...');



            if (pendingProfileSaveTimer) {



                clearTimeout(pendingProfileSaveTimer);



                pendingProfileSaveTimer = null;



            }



            pendingProfileSaveTimer = setTimeout(() => {



                pendingProfileSaveTimer = null;



                void saveInventoryToBackend();



            }, 500);



        }



        /**



         * TEMPORARY: Load inventory from localStorage



         *



         * For testing purposes only. In production, this will be replaced



         * with a proper API call to load the user's inventory from the server.



         *



         * Storage key: 'astoriaInventory'



         * Format: JSON array of inventory items with quantities



         */



        function loadFromLocalStorage() {



            equippedSlots = loadEquippedSlotsFromLocalStorage();



            try {



                const stored = localStorage.getItem('astoriaInventory');



                if (stored) {



                    const parsed = JSON.parse(stored);



                    if (Array.isArray(parsed)) {



                        inventoryItems = parsed;



                    } else if (parsed && Array.isArray(parsed.items)) {



                        // Allow reading compact format if we ever store it locally too



                        hydrateInventoryFromCompact(parsed.items);



                        if (parsed.equippedSlots || parsed.equipped) {



                            equippedSlots = normalizeEquippedSlots(parsed.equippedSlots || parsed.equipped);



                        }



                    } else {



                        inventoryItems = [];



                    }



                    nextItemId = Math.max(...inventoryItems.map(i => i.id), 0) + 1;



                    console.log(`Loaded ${inventoryItems.length} items from localStorage`);



                } else {



                    inventoryItems = [];



                    console.log('No inventory found in localStorage - starting empty');



                }



            } catch (error) {



                console.error('Error loading from localStorage:', error);



                inventoryItems = [];



            }



        }



        /**



         * TEMPORARY: Save inventory to localStorage



         *



         * For testing purposes only. In production, this will be replaced



         * with API calls to persist changes to the server.



         */



        function saveToLocalStorage() {



            try {



                localStorage.setItem('astoriaInventory', JSON.stringify(inventoryItems));



                localStorage.setItem(EQUIPPED_SLOTS_STORAGE_KEY, JSON.stringify(serializeEquippedSlots()));



                console.log('Inventory saved to localStorage');



            } catch (error) {



                console.error('Error saving to localStorage:', error);



            }



        }



        // =================================================================



        // ADD ITEM PANEL



        // =================================================================



        /**



         * Open the add item panel



         * Pre-selects the current category filter for convenience



         */



        function openAddPanel() {



            addPanel.classList.add('open');



            // Pre-select current category (or "all" if viewing all)



            categorySelect.value = currentCategory;



            // Populate items based on pre-selected category



            populateItemSelector();



            // Reset other form fields



            itemSelect.value = '';



            quantityInput.value = 1;



            itemPreview.style.display = 'none';



        }



        /**



         * Close the add item panel



         */



        function closeAddPanel() {



            addPanel.classList.remove('open');



            resetAddForm();



        }



        /**



         * Reset the add form to defaults



         */



        function resetAddForm() {



            itemSelect.value = '';



            categorySelect.value = 'all';



            quantityInput.value = 1;



            itemPreview.style.display = 'none';



            populateItemSelector(); // Refresh item list



        }



        /**



         * Handle category change - refresh item dropdown



         */



        function handleCategoryChange() {



            // Refresh item dropdown with filtered items



            populateItemSelector();



            // Clear item selection since list changed



            itemSelect.value = '';



            itemPreview.style.display = 'none';



        }



        /**



         * Handle item selection - show preview



         */



        function handleItemSelection() {



            const selectedIndex = itemSelect.value;



            if (!selectedIndex) {



                itemPreview.style.display = 'none';



                return;



            }



            const allItems = getAllItems();



            const selectedItem = allItems[parseInt(selectedIndex)];



            if (selectedItem) {



                // Show preview



                const imageSrc = resolveImage(selectedItem);



                previewImage.src = imageSrc;



                previewImage.onerror = () => { previewImage.src = PLACEHOLDER_IMAGE; };



                previewName.textContent = selectedItem.name;



                previewDescription.textContent = selectedItem.description || 'Aucune description disponible.';



                itemPreview.style.display = 'block';



            }



        }



        /**



         * Add selected item to inventory



         */



        function addItemToInventory() {



            const selectedIndex = itemSelect.value;



            const quantity = parseInt(quantityInput.value) || 1;



            if (!selectedIndex) {



                alert('Veuillez s√©lectionner un objet');



                return;



            }



            if (quantity < 1) {



                alert('La quantit√© doit √™tre au moins 1');



                return;



            }



            const allItems = getAllItems();



            const sourceItem = allItems[parseInt(selectedIndex)];



            const sourceIndex = parseInt(selectedIndex);



            if (!sourceItem) {



                alert('Objet invalide');



                return;



            }



            // Check if item already exists in inventory



            const existingItem = inventoryItems.find(i => i.sourceIndex === sourceIndex || i.name === sourceItem.name);



            if (existingItem) {



                // Update quantity if already exists



                existingItem.quantity += quantity;



                if (!Number.isFinite(Number(existingItem.sourceIndex))) {



                    existingItem.sourceIndex = sourceIndex;



                }



                console.log(`Updated ${existingItem.name}: quantity now ${existingItem.quantity}`);



            } else {



                // Add new item with all data from source (use original category from data)



                const newItem = {



                    id: nextItemId++,



                    sourceIndex,



                    name: sourceItem.name,



                    category: sourceItem.category, // Use original category from data



                    image: sourceItem.image,



                    description: sourceItem.description,



                    effect: sourceItem.effect,



                    buyPrice: sourceItem.buyPrice,



                    sellPrice: sourceItem.sellPrice,



                    quantity: quantity



                };



                inventoryItems.push(newItem);



                console.log(`Added ${newItem.name} x${quantity} to inventory`);



            }



            persistInventory();



            // Close panel and refresh display



            closeAddPanel();



            renderInventory();



        }



        /**



         * Quantity control buttons



         */



        function decreaseQuantity() {



            const current = parseInt(quantityInput.value) || 1;



            quantityInput.value = Math.max(1, current - 1);



        }



        function increaseQuantity() {



            const current = parseInt(quantityInput.value) || 1;



            quantityInput.value = current + 1;



        }



        // Attach event listeners for add panel



        openAddBtn.addEventListener('click', openAddPanel);



        closeAddBtn.addEventListener('click', closeAddPanel);



        cancelAddBtn.addEventListener('click', closeAddPanel);



        confirmAddBtn.addEventListener('click', addItemToInventory);



        categorySelect.addEventListener('change', handleCategoryChange);



        itemSelect.addEventListener('change', handleItemSelection);



        qtyMinusBtn.addEventListener('click', decreaseQuantity);



        qtyPlusBtn.addEventListener('click', increaseQuantity);



        document.addEventListener('keydown', (event) => {



            if (event.key !== 'Escape') return;



            if (addPanel.classList.contains('open')) {



                closeAddPanel();



            }



        });



        if (scrollPanelAddBtn) {



            scrollPanelAddBtn.addEventListener('click', () => {



                if (scrollPanelAddBtn.disabled) return;



                setScrollAddOpen(!scrollAddOpen);



                renderScrollSuggestions(scrollTypeSearch?.value || '');



                syncScrollPanelHeights();



            });



        }



        if (scrollTypeSearch) {



            scrollTypeSearch.addEventListener('input', (event) => {



                renderScrollSuggestions(event.target.value);



                syncScrollPanelHeights();



            });



        }



        if (scrollTypeSuggestions) {



            scrollTypeSuggestions.addEventListener('click', (event) => {



                const addButton = event.target.closest('.scroll-suggestion-add');



                if (!addButton) return;



                const row = addButton.closest('.scroll-suggestion-row');



                if (!row) return;



                const qtyInput = row.querySelector('.scroll-suggestion-qty');



                addScrollTypeCount(row.dataset.typeKey, qtyInput?.value);



                if (qtyInput) qtyInput.value = 1;



            });



        }



        if (scrollPanelList) {



            scrollPanelList.addEventListener('click', (event) => {



                const addButton = event.target.closest('.scroll-type-add');



                const removeButton = event.target.closest('.scroll-type-remove');



                const qtyButton = event.target.closest('.scroll-type-qty-btn');



                const item = event.target.closest('.scroll-type-item');



                if (!item) return;



                const typeKey = item.dataset.typeKey;



                if (addButton) {



                    const qtyInput = item.querySelector('.scroll-type-qty-input');



                    addScrollTypeCount(typeKey, qtyInput?.value);



                    if (qtyInput) qtyInput.value = 1;



                    return;



                }



                if (removeButton) {



                    const qtyInput = item.querySelector('.scroll-type-qty-input');



                    removeScrollTypeCount(typeKey, qtyInput?.value);



                    if (qtyInput) qtyInput.value = 1;



                    return;



                }



                if (qtyButton) {



                    const qtyInput = item.querySelector('.scroll-type-qty-input');



                    if (!qtyInput) return;



                    const current = parseInt(qtyInput.value, 10) || 1;



                    const action = qtyButton.dataset.action;



                    qtyInput.value = Math.max(1, action === 'minus' ? current - 1 : current + 1);



                    return;



                }



                const row = event.target.closest('.scroll-type-row');



                if (row) {



                    selectedScrollTypeKey = typeKey;



                    if (currentScrollItem && scrollPanelCategory) {



                        const { counts } = loadScrollCounts(scrollPanelCategory, currentScrollItem);



                        renderScrollPanelList(scrollPanelCategory, counts);



                    }



                }



            });



            scrollPanelList.addEventListener('keydown', (event) => {



                if (event.key !== 'Enter') return;



                const input = event.target.closest('.scroll-type-qty-input');



                if (!input) return;



                const item = input.closest('.scroll-type-item');



                if (!item) return;



                addScrollTypeCount(item.dataset.typeKey, input.value);



                input.value = 1;



            });



        }



        window.addEventListener('resize', syncScrollPanelHeights);



        // =================================================================



        // CATEGORY FILTERING



        // =================================================================



        /**



         * Filter inventory by category



         * - Updates active button



         * - Clears selection



         * - Re-renders grid



         */



        function filterByCategory(category) {



            currentCategory = category;



            selectedItemIndex = null;



            // Update active button



            categoryButtons.forEach(btn => {



                if (btn.dataset.category === category) {



                    btn.classList.add('active');



                } else {



                    btn.classList.remove('active');



                }



            });



            renderInventory();



        }



        // Attach click handlers to category buttons



        categoryButtons.forEach(btn => {



            btn.addEventListener('click', () => {



                filterByCategory(btn.dataset.category);



            });



        });



        if (searchRoot && searchInput && window.astoriaSearchBar) {



            window.astoriaSearchBar.bind({



                root: searchRoot,



                input: searchInput,



                toggle: searchToggle,



                clearButton: searchClear,



                dropdown: searchHistoryDropdown,



                history: searchHistory,



                hotkey: ' ',



                debounceWait: 200,



                onSearch: (value) => {



                    currentSearchQuery = String(value || '').trim().toLowerCase();



                    renderInventory();



                }



            });



        }



        // =================================================================



        // IMAGE RESOLUTION



        // =================================================================



        /**



         * Resolve image path from item data



         * - Checks IMAGE_CONFIG mappings



         * - Supports direct URLs



         * - Falls back to placeholder



         */



        function resolveImage(item) {



            const helpers = window.astoriaImageHelpers || {};



            if (helpers.resolveItemImages) {



                const resolved = helpers.resolveItemImages(item);



                if (resolved && resolved.primary) {



                    return resolved.primary;



                }



            }



            // Fallback local (au cas o√π le helper n'est pas disponible)



            if (item) {



                const raw = item.image || item.img || item?.images?.primary || item?.images?.url || '';



                if (typeof raw === 'string' && raw.trim()) {



                    return raw;



                }



                const name = String(item.name || '').trim().toLowerCase();



                if (name === 'lucky soul') {



                    return 'assets/nokorah/lucky-soul.svg';



                }



            }



            // No match found, use placeholder



            return PLACEHOLDER_IMAGE;



        }



        // =================================================================



        // SCROLL TYPES PANEL



        // =================================================================



        const normalizeText = window.astoriaListHelpers.normalizeText;



        function getScrollCategory(item) {



            const helper = window.astoriaItemTags;



            if (helper?.getScrollCategory) {



                return helper.getScrollCategory(item);



            }



            if (!item || !item.name) return null;



            const name = normalizeText(item.name);



            if (!name.includes('parchemin') && !name.includes('scroll')) return null;



            if (name.includes('eveil') || name.includes('eveille') || (name.includes('veil') && name.includes('parchemin'))) return 'eveil';



            if (name.includes('ascension')) return 'ascension';



            return null;



        }



        function getScrollTypeKey(item) {



            const taggedKey = window.astoriaItemTags?.getScrollTypeKeyFromTags?.(item);



            if (taggedKey) return taggedKey;



            const haystack = normalizeText(



                [item?.name, item?.description, item?.effect]



                    .filter(Boolean)



                    .join(' ')



            );



            for (const type of SCROLL_TYPES) {



                for (const matcher of type.matchers) {



                    if (haystack.includes(normalizeText(matcher))) {



                        return type.key;



                    }



                }



            }



            return null;



        }



        const SCROLL_STORAGE_PREFIX = 'astoriaScrollTypes:v1';



        function getEmptyScrollCounts() {



            const counts = {};



            SCROLL_TYPES.forEach((type) => {



                counts[type.key] = 0;



            });



            return counts;



        }



        function getScrollItemKey(item) {



            const sourceIndex = Number(item?.sourceIndex);



            if (Number.isFinite(sourceIndex)) {



                return `idx:${sourceIndex}`;



            }



            const name = item?.name ? normalizeText(item.name) : '';



            if (name) {



                return `name:${name}`;



            }



            const id = Number(item?.id);



            if (Number.isFinite(id)) {



                return `id:${id}`;



            }



            return 'unknown';



        }



        function getScrollStorageKey(category, item, useLegacy = false) {



            const idPart = useLegacy ? (item?.id ?? item?.name ?? 'unknown') : getScrollItemKey(item);



            return `${SCROLL_STORAGE_PREFIX}:${category}:${idPart}`;



        }



        function clearScrollCountsForItem(item) {



            const category = getScrollCategory(item);



            if (!category || !item) return;



            const itemKey = getScrollItemKey(item);



            if (scrollTypeStore?.[category]) {



                delete scrollTypeStore[category][itemKey];



                if (Object.keys(scrollTypeStore[category]).length === 0) {



                    delete scrollTypeStore[category];



                }



            }



            const key = getScrollStorageKey(category, item, false);



            const legacyKey = getScrollStorageKey(category, item, true);



            try {



                localStorage.removeItem(key);



                if (legacyKey !== key) {



                    localStorage.removeItem(legacyKey);



                }



            } catch {



                // ignore storage cleanup failures



            }



        }



        function resetScrollCountsAfterQtyChange(item) {



            const category = getScrollCategory(item);



            if (!category) return;



            clearScrollCountsForItem(item);



            const nextQty = Math.max(0, Math.floor(Number(item?.quantity) || 0));



            const seededTypeKey = getScrollTypeKey(item);



            if (seededTypeKey && nextQty > 0) {



                const counts = getEmptyScrollCounts();



                if (counts[seededTypeKey] === undefined) {



                    counts[seededTypeKey] = 0;



                }



                counts[seededTypeKey] = nextQty;



                saveScrollCounts(category, item, counts);



            } else {



                persistInventory();



            }



        }



        function normalizeScrollCounts(rawCounts) {



            const counts = getEmptyScrollCounts();



            if (!rawCounts) return counts;



            Object.keys(rawCounts).forEach((typeKey) => {



                if (counts[typeKey] === undefined) {



                    counts[typeKey] = 0;



                }



            });



            Object.keys(counts).forEach((typeKey) => {



                const value = Number(rawCounts[typeKey]);



                counts[typeKey] = Number.isFinite(value) && value > 0 ? value : 0;



            });



            return counts;



        }



        function buildScrollItemKeyMap() {



            const map = {};



            inventoryItems.forEach((item) => {



                const category = getScrollCategory(item);



                if (!category) return;



                if (!map[category]) {



                    map[category] = new Set();



                }



                map[category].add(getScrollItemKey(item));



            });



            return map;



        }



        function normalizeScrollTypeStore(rawStore) {



            if (!rawStore || typeof rawStore !== 'object') return {};



            const allowedKeys = buildScrollItemKeyMap();



            const cleaned = {};



            Object.entries(rawStore).forEach(([category, items]) => {



                if (!items || typeof items !== 'object') return;



                if (!allowedKeys[category]) return;



                const cleanedItems = {};



                Object.entries(items).forEach(([itemKey, entry]) => {



                    if (!allowedKeys[category].has(itemKey)) return;



                    const counts = normalizeScrollCounts(entry?.counts);



                    const hasAny = Object.values(counts).some((value) => value > 0);



                    if (!hasAny) return;



                    cleanedItems[itemKey] = {



                        counts,



                        updatedAt: entry?.updatedAt || Date.now()



                    };



                });



                if (Object.keys(cleanedItems).length) {



                    cleaned[category] = cleanedItems;



                }



            });



            return cleaned;



        }



        function getScrollStoreEntry(category, item) {



            if (!scrollTypeStore || typeof scrollTypeStore !== 'object') return null;



            const itemKey = getScrollItemKey(item);



            const bucket = scrollTypeStore[category];



            if (!bucket || typeof bucket !== 'object') return null;



            return bucket[itemKey] || null;



        }



        function setScrollStoreEntry(category, item, counts) {



            if (!scrollTypeStore || typeof scrollTypeStore !== 'object') {



                scrollTypeStore = {};



            }



            const itemKey = getScrollItemKey(item);



            if (!scrollTypeStore[category]) {



                scrollTypeStore[category] = {};



            }



            scrollTypeStore[category][itemKey] = {



                counts: normalizeScrollCounts(counts),



                updatedAt: Date.now()



            };



        }



        function loadScrollCountsFromLocalStorage(category, item) {



            const counts = getEmptyScrollCounts();



            const key = getScrollStorageKey(category, item, false);



            const legacyKey = getScrollStorageKey(category, item, true);



            const raw = localStorage.getItem(key) || (legacyKey !== key ? localStorage.getItem(legacyKey) : null);



            if (raw) {



                try {



                    const parsed = JSON.parse(raw);



                    if (parsed && typeof parsed === 'object' && parsed.counts) {



                        return { counts: normalizeScrollCounts(parsed.counts), hasStored: true };



                    }



                } catch (error) {



                    console.warn('Scroll counts parse failed:', error);



                }



            }



            return { counts, hasStored: false };



        }



        function loadScrollCountsFromProfile(category, item) {



            const entry = getScrollStoreEntry(category, item);



            if (entry && entry.counts) {



                return { counts: normalizeScrollCounts(entry.counts), hasStored: true };



            }



            return { counts: getEmptyScrollCounts(), hasStored: false };



        }



        function loadScrollCounts(category, item) {



            if (!category || !item) {



                return { counts: getEmptyScrollCounts(), hasStored: false };



            }



            if (inventoryStorageMode === 'character' && authApi) {



                const fromProfile = loadScrollCountsFromProfile(category, item);



                if (fromProfile.hasStored) return fromProfile;



                if (!inventoryMigrated) {



                    const legacy = loadScrollCountsFromLocalStorage(category, item);



                    if (legacy.hasStored) {



                        setScrollStoreEntry(category, item, legacy.counts);



                        return legacy;



                    }



                }



            }



            const local = loadScrollCountsFromLocalStorage(category, item);



            if (local.hasStored) return local;



            const seededTypeKey = getScrollTypeKey(item);



            const seededQty = Math.max(0, Number(item.quantity) || 0);



            if (seededTypeKey && seededQty > 0) {



                const counts = getEmptyScrollCounts();



                if (counts[seededTypeKey] === undefined) {



                    counts[seededTypeKey] = 0;



                }



                counts[seededTypeKey] = seededQty;



                saveScrollCounts(category, item, counts);



                return { counts, hasStored: true };



            }



            return { counts: getEmptyScrollCounts(), hasStored: false };



        }



        function saveScrollCounts(category, item, counts) {



            if (!category || !item) return;



            const payload = {



                counts: normalizeScrollCounts(counts),



                updatedAt: Date.now()



            };



            const key = getScrollStorageKey(category, item, false);



            localStorage.setItem(key, JSON.stringify(payload));



            if (inventoryStorageMode === 'character' && authApi) {



                setScrollStoreEntry(category, item, payload.counts);



                persistInventory();



            }



        }



        function sumScrollCounts(counts) {



            return Object.values(counts).reduce((sum, value) => sum + (Number(value) || 0), 0);



        }



        function syncScrollPanelHeights() {



            if (!scrollTypesPanel || !detailPanel || !scrollPanelHeader || !scrollPanelBody) return;



            const detailHeight = detailPanel.offsetHeight;



            if (!detailHeight) return;



            scrollTypesPanel.style.maxHeight = `${detailHeight}px`;



            const panelStyles = window.getComputedStyle(scrollTypesPanel);



            const paddingTop = parseFloat(panelStyles.paddingTop) || 0;



            const paddingBottom = parseFloat(panelStyles.paddingBottom) || 0;



            const headerHeight = scrollPanelHeader.offsetHeight;



            const maxBodyHeight = Math.max(160, detailHeight - headerHeight - paddingTop - paddingBottom);



            scrollPanelBody.style.maxHeight = `${maxBodyHeight}px`;



        }



        function setScrollPanelOpen(isOpen) {



            scrollPanelOpen = isOpen;



            if (inventoryContent) {



                inventoryContent.classList.toggle('scroll-panel-open', isOpen);



            }



            if (scrollTypesPanel) {



                scrollTypesPanel.classList.toggle('open', isOpen);



                scrollTypesPanel.setAttribute('aria-hidden', String(!isOpen));



            }



            if (scrollPanelToggleBtn) {



                scrollPanelToggleBtn.setAttribute('aria-expanded', String(isOpen));



            }



            if (!isOpen) {



                setScrollAddOpen(false);



            }



            syncScrollPanelHeights();



        }



        function setScrollPanelEmpty(message) {



            if (!scrollPanelTitle || !scrollPanelEmpty || !scrollPanelList) return;



            scrollPanelTitle.textContent = 'Types de parchemins';



            scrollPanelEmpty.textContent = message;



            scrollPanelEmpty.style.display = 'block';



            scrollPanelList.innerHTML = '';



            scrollPanelList.style.display = 'none';



        }



        function renderScrollPanelList(category, counts) {



            if (!scrollPanelTitle || !scrollPanelList || !scrollPanelEmpty) return;



            const titleText = category === 'eveil' ? '\u00c9veil' : 'Ascension';



            const visibleKeys = Object.keys(counts).filter((key) => (counts[key] || 0) > 0);



            const visibleTypes = visibleKeys



                .map((key) => getScrollTypeMetaByKey(key))



                .filter(Boolean);



            scrollPanelTitle.textContent = titleText;



            if (visibleTypes.length === 0) {



                scrollPanelEmpty.textContent = 'Aucun type enregistr√© pour ce parchemin.';



                scrollPanelEmpty.style.display = 'block';



                scrollPanelList.innerHTML = '';



                scrollPanelList.style.display = 'none';



                return;



            }



            scrollPanelEmpty.style.display = 'none';



            scrollPanelList.style.display = 'grid';



            const rows = visibleTypes.map((type) => {



                const count = counts[type.key] || 0;



                const isSelected = type.key === selectedScrollTypeKey;



                return `



                    <div class="scroll-type-item${isSelected ? ' selected' : ''}" data-type-key="${type.key}">



                        <div class="scroll-type-row">



                            <span class="scroll-type-label">${escapeHtml(type.emoji)} ${escapeHtml(type.label)}</span>



                            <span class="scroll-type-count">x${count}</span>



                        </div>



                        ${isSelected ? `



                        <div class="scroll-type-controls">



                            <button type="button" class="scroll-type-qty-btn tw-press" data-action="minus">-</button>



                            <input type="number" min="1" value="1" class="scroll-type-qty-input">



                            <button type="button" class="scroll-type-qty-btn tw-press" data-action="plus">+</button>



                            <button type="button" class="scroll-type-add tw-press">Ajouter</button>



                            <button type="button" class="scroll-type-remove tw-press">Retirer</button>



                        </div>



                        ` : ''}



                    </div>



                `;



            }).join('');



            scrollPanelList.innerHTML = rows;



        }



        function setScrollAddOpen(isOpen) {



            scrollAddOpen = isOpen;



            if (!scrollPanelAdd || !scrollPanelAddBtn) return;



            scrollPanelAdd.classList.toggle('open', isOpen);



            scrollPanelAdd.setAttribute('aria-hidden', String(!isOpen));



            scrollPanelAddBtn.setAttribute('aria-expanded', String(isOpen));



            if (!isOpen && scrollTypeSearch) {



                scrollTypeSearch.value = '';



            }



        }



        function renderScrollSuggestions(filterText) {



            if (!scrollTypeSuggestions) return;



            const term = normalizeText(filterText);



            const filtered = SCROLL_TYPES.filter((type) => {



                if (!term) return true;



                if (normalizeText(type.label).includes(term)) return true;



                if (normalizeText(type.key).includes(term)) return true;



                return type.matchers?.some((matcher) => normalizeText(matcher).includes(term));



            });



            if (filtered.length === 0) {



                scrollTypeSuggestions.innerHTML = '<div class="scroll-suggestion-empty">Aucun type trouv√©.</div>';



                return;



            }



            scrollTypeSuggestions.innerHTML = filtered.map((type) => {



                return `



                    <div class="scroll-suggestion-row" data-type-key="${type.key}">



                        <span class="scroll-suggestion-label">${escapeHtml(type.emoji)} ${escapeHtml(type.label)}</span>



                        <div class="scroll-suggestion-controls">



                            <input type="number" min="1" value="1" class="scroll-suggestion-qty">



                            <button type="button" class="scroll-suggestion-add tw-press">Ajouter</button>



                        </div>



                    </div>



                `;



            }).join('');



        }



        function addScrollTypeCount(typeKey, qty) {



            if (!currentScrollItem || !scrollPanelCategory) return;



            const safeQty = Math.max(0, Math.floor(Number(qty) || 0));



            if (safeQty < 1) return;



            const { counts } = loadScrollCounts(scrollPanelCategory, currentScrollItem);



            if (counts[typeKey] === undefined) counts[typeKey] = 0;



            counts[typeKey] = (counts[typeKey] || 0) + safeQty;



            saveScrollCounts(scrollPanelCategory, currentScrollItem, counts);



            const total = sumScrollCounts(counts);



            currentScrollItem.quantity = total;



            persistInventory();



            renderInventory();



            showItemDetail(currentScrollItem);



        }



        function removeScrollTypeCount(typeKey, qty) {



            if (!currentScrollItem || !scrollPanelCategory) return;



            const safeQty = Math.max(0, Math.floor(Number(qty) || 0));



            if (safeQty < 1) return;



            const { counts } = loadScrollCounts(scrollPanelCategory, currentScrollItem);



            if (counts[typeKey] === undefined) counts[typeKey] = 0;



            const current = Number(counts[typeKey]) || 0;



            const next = Math.max(0, current - safeQty);



            counts[typeKey] = next;



            const total = sumScrollCounts(counts);



            if (total <= 0) {



                clearScrollCountsForItem(currentScrollItem);



                currentScrollItem.quantity = 0;



                const index = inventoryItems.findIndex((entry) => entry?.id === currentScrollItem?.id);



                if (index >= 0) {



                    inventoryItems.splice(index, 1);



                    if (selectedItemIndex === currentScrollItem?.id) {



                        selectedItemIndex = null;



                        showDetailPlaceholder();



                    }



                }



            } else {



                saveScrollCounts(scrollPanelCategory, currentScrollItem, counts);



                currentScrollItem.quantity = total;



            }



            persistInventory();



            renderInventory();



            if (selectedItemIndex === currentScrollItem?.id && total > 0) {



                showItemDetail(currentScrollItem);



            }



        }



        function updateScrollPanelForItem(item) {



            const category = getScrollCategory(item);



            scrollPanelCategory = category;



            currentScrollItem = item || null;



            const nextItemId = item?.id ?? null;



            if (nextItemId !== lastScrollItemId) {



                selectedScrollTypeKey = null;



                scrollAddOpen = true;



                lastScrollItemId = nextItemId;



            }



            if (!category) {



                if (scrollPanelToggleBtn) {



                    scrollPanelToggleBtn.disabled = true;



                    scrollPanelToggleBtn.setAttribute('aria-expanded', 'false');



                }



                if (scrollPanelAddBtn) {



                    scrollPanelAddBtn.disabled = true;



                }



                setScrollPanelOpen(false);



                setScrollPanelEmpty('Aucun type de parchemin disponible.');



                return;



            }



            if (scrollPanelToggleBtn) {



                scrollPanelToggleBtn.disabled = false;



            }



            if (scrollPanelAddBtn) {



                scrollPanelAddBtn.disabled = false;



            }



            const { counts, hasStored } = loadScrollCounts(category, item);



            if (hasStored) {



                const total = sumScrollCounts(counts);



                if (Number.isFinite(total) && item.quantity !== total) {



                    item.quantity = total;



                    persistInventory();



                }



            }



            renderScrollPanelList(category, counts);



            setScrollAddOpen(scrollAddOpen);



            renderScrollSuggestions(scrollTypeSearch?.value || '');



            syncScrollPanelHeights();



        }



        // =================================================================



        // RENDERING



        // =================================================================



        function getItemModifierTools() {



            return window.astoriaItemModifiers || null;



        }



        function getItemModifiers(item) {



            const tools = getItemModifierTools();



            if (tools?.getModifiers) {



                return tools.getModifiers(item);



            }



            return [];



        }



        function renderModifierBadges(modifiers, limit = 3) {



            const tools = getItemModifierTools();



            const badgeModels = tools?.toBadgeModel ? tools.toBadgeModel(modifiers) : [];



            if (!badgeModels.length) return '';



            const shown = badgeModels.slice(0, Math.max(1, limit));



            const badges = shown.map((badge) => {



                const stateClass = badge.positive ? 'is-positive' : 'is-negative';



                return `<span class="item-modifier-badge ${stateClass}">${escapeHtml(badge.label)}</span>`;



            }).join('');



            const remaining = badgeModels.length - shown.length;



            const more = remaining > 0 ? `<span class="item-modifier-more">+${remaining}</span>` : '';



            return `<div class="item-modifiers-inline">${badges}${more}</div>`;



        }



        function renderModifierLines(modifiers) {



            const tools = getItemModifierTools();



            const badgeModels = tools?.toBadgeModel ? tools.toBadgeModel(modifiers) : [];



            if (!badgeModels.length) return '';



            const rows = badgeModels.map((badge) => {



                const stateClass = badge.positive ? 'is-positive' : 'is-negative';



                return `<li class="item-modifier-line ${stateClass}">${escapeHtml(badge.label)}</li>`;



            }).join('');



            return `<div class="detail-section"><span class="detail-label">Modificateurs</span><ul class="item-modifiers-list">${rows}</ul></div>`;



        }



        function isItemEquippable(item) {



            return Boolean(item && !item.isCurrency && item.category === 'equipement');



        }



        /**
         * Map codex equipment_slot values (French) to inventory slot keys (English)
         */
        const SLOT_MAP = {
            'casque': 'head',
            'cape': 'cape',
            'epaulettes': 'shoulders',
            'collier': 'amulet',
            'plastron': 'chest',
            'ceinture': 'belt',
            'gantelets': 'gloves',
            'anneau': 'anneau',
            'bottes': 'boots',
            'arme': 'weapon',
            'arme-principale': 'weapon',
            'arme-une-main': 'weapon',
            'arme-deux-mains': 'offhand',
            'arme-secondaire': 'offhand',
            'artefact': 'artifact',
            'familier': 'companion',
            'monture': 'mount'
        };

        function normalizeSlot(rawSlot) {
            if (!rawSlot) return null;
            return SLOT_MAP[rawSlot] || rawSlot;
        }

        /**
         * Get the normalized equipment slot from an item
         * Checks both equipment_slot (DB) and equipmentSlot (JS) fields
         */
        function getItemSlot(item) {
            const raw = item?.equipment_slot || item?.equipmentSlot || null;
            return normalizeSlot(raw);
        }

        /**
         * Check if an item's equipment slot is compatible with target slot
         * Handles special cases like rings (anneau -> ring1 or ring2)
         * STRICT: items without equipmentSlot cannot be equipped
         */
        function isSlotCompatible(itemSlot, targetSlot) {
            const normalized = normalizeSlot(itemSlot);
            if (!normalized) return false; // STRICT: items must have equipmentSlot defined

            // Direct match
            if (normalized === targetSlot) return true;

            // Ring slots: "anneau" can go to ring1 or ring2
            if (normalized === 'anneau' && (targetSlot === 'ring1' || targetSlot === 'ring2')) {
                return true;
            }

            return false;
        }



        /**
         * Find first available slot for an item
         * Returns slot key or null if no slot available
         */
        function findAvailableSlot(item) {
            const slot = getItemSlot(item);
            if (!slot) return null;

            // For rings, find first available ring slot
            if (slot === 'anneau') {
                if (!equippedSlots['ring1']) return 'ring1';
                if (!equippedSlots['ring2']) return 'ring2';
                return 'ring1'; // Replace first ring if both occupied
            }

            // For other items, return the direct slot
            return slot;
        }



        function buildEquippedItem(itemKey, itemIndex) {



            const resolved = resolveItemByKey(itemKey, itemIndex);



            const sourceItem = resolved?.item;



            if (!sourceItem) return null;



            return {



                sourceIndex: Number.isFinite(resolved.index) ? resolved.index : null,



                name: sourceItem.name,



                category: sourceItem.category,



                image: sourceItem.image,



                images: sourceItem.images,



                description: sourceItem.description,



                effect: sourceItem.effect,



                modifiers: Array.isArray(sourceItem.modifiers) ? sourceItem.modifiers : [],



                buyPrice: sourceItem.buyPrice,



                sellPrice: sourceItem.sellPrice,



                quantity: 1



            };



        }



        function normalizeEquippedSlots(rawSlots) {



            if (!rawSlots || typeof rawSlots !== 'object') return {};



            const normalized = {};



            EQUIPMENT_SLOT_DEFS.forEach((slot) => {



                const entry = rawSlots[slot.key];



                if (!entry) return;



                const equippedItem = buildEquippedItem(entry.item_key || entry.name, entry.item_index ?? entry.sourceIndex);



                if (!equippedItem || !isItemEquippable(equippedItem)) return;



                normalized[slot.key] = equippedItem;



            });



            return normalized;



        }



        function serializeEquippedSlots() {



            const serialized = {};



            Object.entries(equippedSlots || {}).forEach(([slotKey, item]) => {



                if (!item?.name) return;



                serialized[slotKey] = {



                    item_key: item.name,



                    item_index: Number.isFinite(Number(item.sourceIndex)) ? Number(item.sourceIndex) : null



                };



            });



            return serialized;



        }



        function loadEquippedSlotsFromLocalStorage() {



            try {



                const raw = localStorage.getItem(EQUIPPED_SLOTS_STORAGE_KEY);



                if (!raw) return {};



                return normalizeEquippedSlots(JSON.parse(raw));



            } catch (error) {



                console.warn('Failed to load equipped slots from localStorage:', error);



                return {};



            }



        }



        function ensureInventoryCopy(item, quantity = 1) {



            if (!item?.name) return;



            const sourceIndex = Number.isFinite(Number(item.sourceIndex)) ? Number(item.sourceIndex) : null;



            const existing = inventoryItems.find((entry) => {



                if (entry?.isCurrency) return false;



                if (sourceIndex != null && Number(entry.sourceIndex) === sourceIndex) return true;



                return normalizeItemName(entry?.name) === normalizeItemName(item.name);



            });



            if (existing) {



                existing.quantity = Math.max(0, Math.floor(Number(existing.quantity) || 0)) + quantity;



                if (!Number.isFinite(Number(existing.sourceIndex)) && sourceIndex != null) {



                    existing.sourceIndex = sourceIndex;



                }



                return;



            }



            const resolved = buildEquippedItem(item.name, sourceIndex);



            if (!resolved) return;



            inventoryItems.push({



                id: nextItemId++,



                ...resolved,



                quantity



            });



        }



        function unequipSlot(slotKey, shouldPersist = true) {



            const equippedItem = equippedSlots?.[slotKey];



            if (!equippedItem) return false;



            ensureInventoryCopy(equippedItem, 1);



            delete equippedSlots[slotKey];



            if (shouldPersist) {



                persistInventory();



                renderInventory();



            }



            return true;



        }



        function equipItemToSlot(itemId, slotKey) {



            const inventoryIndex = inventoryItems.findIndex((entry) => entry.id === itemId);



            if (inventoryIndex < 0) return;



            const item = inventoryItems[inventoryIndex];



            if (!isItemEquippable(item)) return;



            // Validate slot compatibility - STRICT: items must have equipmentSlot
            const itemSlot = getItemSlot(item);
            if (!itemSlot) {
                toastManager.error(`Cet objet n'a pas de slot d'√©quipement d√©fini`);
                return;
            }

            if (!isSlotCompatible(itemSlot, slotKey)) {
                const slotDef = EQUIPMENT_SLOT_DEFS.find(s => s.key === slotKey);
                const slotLabel = slotDef ? slotDef.label : slotKey;
                toastManager.error(`Cet objet ne peut pas √™tre √©quip√© dans le slot ${slotLabel}`);
                return;
            }



            const occupied = equippedSlots?.[slotKey];



            if (occupied) {



                unequipSlot(slotKey, false);



            }



            item.quantity = Math.max(0, Math.floor(Number(item.quantity) || 0) - 1);



            if (item.quantity <= 0) {



                inventoryItems.splice(inventoryIndex, 1);



                if (selectedItemIndex === item.id) {



                    selectedItemIndex = null;



                    showDetailPlaceholder();



                }



            }



            equippedSlots[slotKey] = {



                sourceIndex: Number.isFinite(Number(item.sourceIndex)) ? Number(item.sourceIndex) : null,



                name: item.name,



                category: item.category,



                image: item.image,



                images: item.images,



                description: item.description,



                effect: item.effect,



                modifiers: Array.isArray(item.modifiers) ? item.modifiers : [],



                buyPrice: item.buyPrice,



                sellPrice: item.sellPrice,



                quantity: 1



            };



            persistInventory();



            renderInventory();



        }



        function clearSlotDropTargets() {



            document.querySelectorAll('.character-slot.is-drop-target').forEach((slotEl) => {



                slotEl.classList.remove('is-drop-target');



            });



        }



        /**
         * Highlight valid target slots for a dragged item
         */
        function highlightValidSlots(item) {
            const itemSlot = getItemSlot(item);
            if (!itemSlot) return;

            // Find all compatible slots
            EQUIPMENT_SLOT_DEFS.forEach((slot) => {
                if (isSlotCompatible(itemSlot, slot.key)) {
                    const slotEl = document.querySelector(`.character-slot[data-slot-key="${slot.key}"]`);
                    if (slotEl) {
                        slotEl.classList.add('is-drop-target');
                    }
                }
            });
        }



        function renderEquipmentSlots() {



            EQUIPMENT_SLOT_DEFS.forEach((slot) => {



                const slotEl = document.querySelector(`.character-slot[data-slot-key="${slot.key}"]`);



                if (!slotEl) return;



                const equippedItem = equippedSlots?.[slot.key];



                slotEl.classList.toggle('has-item', Boolean(equippedItem));



                slotEl.innerHTML = '';



                if (equippedItem) {



                    const img = document.createElement('img');



                    img.className = 'character-slot-item-image';



                    img.src = resolveImage(equippedItem);



                    img.alt = equippedItem.name;



                    img.decoding = 'async';



                    img.onerror = () => {



                        img.src = PLACEHOLDER_IMAGE;



                    };



                    slotEl.appendChild(img);



                    slotEl.draggable = true;



                    slotEl.ondragstart = (event) => {



                        draggedEquipmentSlotKey = slot.key;



                        slotEl.classList.add('is-dragging');



                        if (event.dataTransfer) {



                            event.dataTransfer.effectAllowed = 'move';



                            event.dataTransfer.setData('text/plain', `slot:${slot.key}`);



                        }



                    };



                    slotEl.ondragend = () => {



                        draggedEquipmentSlotKey = null;



                        slotEl.classList.remove('is-dragging');



                        const container = document.querySelector('.inventory-grid-container');



                        if (container) container.classList.remove('is-slot-drop-target');



                    };



                    slotEl.title = `${slot.label}: ${equippedItem.name} (cliquer pour desequiper)`;



                    slotEl.setAttribute('aria-label', `${slot.label}: ${equippedItem.name}. Cliquer pour desequiper.`);



                    return;



                }



                slotEl.draggable = false;



                slotEl.ondragstart = null;



                slotEl.ondragend = null;



                const label = document.createElement('span');



                label.className = 'character-slot-label';



                label.textContent = slot.label;



                slotEl.appendChild(label);



                slotEl.title = `${slot.label}: vide (depose un equipement)`;



                slotEl.setAttribute('aria-label', `${slot.label}: vide. Depose un equipement ici.`);



            });



        }



        function initEquipmentSlots() {



            if (equipmentSlotsBound) {



                renderEquipmentSlots();



                return;



            }



            const slotElements = document.querySelectorAll('.character-slot[data-slot-key]');



            slotElements.forEach((slotEl) => {



                const slotKey = slotEl.dataset.slotKey;



                if (!slotKey) return;



                slotEl.addEventListener('dragover', (event) => {



                    if (!draggedEquipmentItemId) return;



                    event.preventDefault();



                    if (event.dataTransfer) {



                        event.dataTransfer.dropEffect = 'move';



                    }



                    slotEl.classList.add('is-drop-target');



                });



                slotEl.addEventListener('dragleave', () => {



                    slotEl.classList.remove('is-drop-target');



                });



                slotEl.addEventListener('drop', (event) => {



                    event.preventDefault();



                    const transferId = Number(event.dataTransfer?.getData('text/plain'));



                    const itemId = Number.isFinite(transferId) ? transferId : draggedEquipmentItemId;



                    slotEl.classList.remove('is-drop-target');



                    if (!Number.isFinite(itemId) || itemId <= 0) return;



                    equipItemToSlot(itemId, slotKey);



                });



                slotEl.addEventListener('click', () => {



                    if (equippedSlots?.[slotKey]) {



                        unequipSlot(slotKey);



                    }



                });



                slotEl.addEventListener('keydown', (event) => {



                    if (event.key !== 'Enter' && event.key !== ' ') return;



                    event.preventDefault();



                    if (equippedSlots?.[slotKey]) {



                        unequipSlot(slotKey);



                    }



                });



            });



            if (grid && grid.dataset.slotDropBound !== '1') {



                grid.dataset.slotDropBound = '1';



                const gridContainer = document.querySelector('.inventory-grid-container');



                const getDropContainer = () => gridContainer || grid;



                grid.addEventListener('dragover', (event) => {



                    if (!draggedEquipmentSlotKey) return;



                    event.preventDefault();



                    if (event.dataTransfer) {



                        event.dataTransfer.dropEffect = 'move';



                    }



                    getDropContainer()?.classList.add('is-slot-drop-target');



                });



                grid.addEventListener('dragleave', () => {



                    getDropContainer()?.classList.remove('is-slot-drop-target');



                });



                grid.addEventListener('drop', (event) => {



                    if (!draggedEquipmentSlotKey) return;



                    event.preventDefault();



                    getDropContainer()?.classList.remove('is-slot-drop-target');



                    unequipSlot(draggedEquipmentSlotKey);



                    draggedEquipmentSlotKey = null;



                });



            }



            equipmentSlotsBound = true;



            renderEquipmentSlots();



        }



        /**



         * Render the entire inventory grid



         * - Filters by current category



         * - Updates item count



         * - Shows empty state if needed



         * - Creates item cards



         */



        function renderInventory() {



            renderEquipmentSlots();



            // Filter items by category + search



            let filtered = inventoryItems;



            const activeCategory = currentCategory === 'all' ? '' : currentCategory;



            if (filterItems) {



                filtered = filterItems(inventoryItems, {



                    category: activeCategory,



                    getCategory: (item) => item?.category,



                    query: currentSearchQuery,



                    fields: searchFields



                });



            } else {



                if (activeCategory) {



                    filtered = inventoryItems.filter(item => item.category === activeCategory);



                }



                if (currentSearchQuery) {



                    filtered = filtered.filter(item => {



                        const name = String(item?.name || '').toLowerCase();



                        const description = String(item?.description || '').toLowerCase();



                        const effect = String(item?.effect || '').toLowerCase();



                        return name.includes(currentSearchQuery) || description.includes(currentSearchQuery) || effect.includes(currentSearchQuery);



                    });



                }



            }



            if (selectedItemIndex !== null && !filtered.some(item => item.id === selectedItemIndex)) {



                selectedItemIndex = null;



                showDetailPlaceholder();



            }



            // Update count (shows currently filtered count)



            itemCountEl.textContent = `${filtered.length} objet${filtered.length > 1 ? 's' : ''}`;



            // Clear grid



            grid.innerHTML = '';



            // Show empty state if no items



            if (filtered.length === 0) {



                if (emptyStateMessage) {



                    emptyStateMessage.textContent = currentSearchQuery



                        ? 'Aucun objet trouv\u00e9 pour cette recherche.'



                        : 'Votre inventaire est vide dans cette cat\u00e9gorie';



                }



                grid.style.display = 'none';



                emptyState.style.display = 'flex';



                showDetailPlaceholder();



                return;



            }



            // Show grid



            grid.style.display = 'grid';



            emptyState.style.display = 'none';



            // Render each item



            filtered.forEach((item) => {



                const card = createItemCard(item);



                grid.appendChild(card);



            });



        }



        /**



         * Create an item card element



         * - Resolves image



         * - Shows quantity if > 1



         * - Attaches click handler



         */



        function createItemCard(item) {



            const card = document.createElement('div');



            card.className = 'inventory-item';



            card.dataset.itemId = item.id;



            if (item.id === selectedItemIndex) {



                card.classList.add('selected');



            }



            if (isItemEquippable(item)) {



                card.classList.add('inventory-item--draggable');



                card.draggable = true;



                card.addEventListener('dragstart', (event) => {



                    draggedEquipmentItemId = item.id;



                    card.classList.add('is-dragging');



                    // Highlight valid target slots
                    highlightValidSlots(item);



                    if (event.dataTransfer) {



                        event.dataTransfer.effectAllowed = 'move';



                        event.dataTransfer.setData('text/plain', String(item.id));



                    }



                });



                card.addEventListener('dragend', () => {



                    draggedEquipmentItemId = null;



                    card.classList.remove('is-dragging');



                    clearSlotDropTargets();



                });



                // Double-click/tap to auto-equip
                let lastTap = 0;
                card.addEventListener('dblclick', () => {
                    const targetSlot = findAvailableSlot(item);
                    if (targetSlot) {
                        equipItemToSlot(item.id, targetSlot);
                    }
                });

                // Mobile: detect double-tap (300ms threshold)
                card.addEventListener('touchend', (event) => {
                    const currentTime = new Date().getTime();
                    const tapLength = currentTime - lastTap;
                    if (tapLength < 300 && tapLength > 0) {
                        event.preventDefault();
                        const targetSlot = findAvailableSlot(item);
                        if (targetSlot) {
                            equipItemToSlot(item.id, targetSlot);
                        }
                    }
                    lastTap = currentTime;
                });



            }



            // Resolve image



            const imageSrc = resolveImage(item);



            const modifiersHtml = renderModifierBadges(getItemModifiers(item), 2);



            const isCurrency = item?.isCurrency === true;



            const actionHtml = isCurrency



                ? ''



                : `



                    <div class="detail-actions">



                        <button class="item-action-use tw-press"



                                onclick="useItem(${item.id})"



                                title="Utiliser l'objet"



                                ${item.quantity < 1 ? 'disabled' : ''}



                                aria-label="Utiliser l'objet">



                            &#x2728;



                        </button>



                        <div class="action-stack">



                            <button class="item-action-delete tw-press"



                                    onclick="openDeleteModal(${item.id})"



                                    title="Supprimer l'objet"



                                    aria-label="Supprimer l'objet">



                                &#x1F5D1;&#xFE0F;



                            </button>



                            <button class="item-action-scroll-toggle tw-press"



                                    type="button"



                                    id="scrollTypesToggle"



                                    title="Types de parchemins"



                                    aria-label="Afficher les types de parchemins"



                                    aria-expanded="false"



                                    aria-controls="scrollTypesPanel">



                                &#x25BE;



                            </button>



                        </div>



                    </div>



                `;



            card.innerHTML = `



                <div class="item-image">



                    <img src="${escapeHtml(imageSrc)}"



                         alt="${escapeHtml(item.name)}"



                         decoding="async"



                         onerror="this.src='${PLACEHOLDER_IMAGE}'">



                </div>



                <div class="item-info">



                    <div class="item-name">${escapeHtml(item.name)}</div>



                    ${item.quantity > 1 ? `<div class="item-quantity">x${item.quantity}</div>` : ''}



                    ${modifiersHtml}



                </div>



            `;



            // Click to select



            card.addEventListener('click', () => selectItem(item, card));



            return card;



        }



        // =================================================================



        // ITEM SELECTION & DETAILS



        // =================================================================



        /**



         * Select an item and show its details



         * - Removes previous selection



         * - Marks new selection



         * - Updates detail panel



         */



        function selectItem(item, cardElement) {



            // Remove previous selection



            document.querySelectorAll('.inventory-item').forEach(el => {



                el.classList.remove('selected');



            });



            // Mark as selected



            cardElement.classList.add('selected');



            selectedItemIndex = item.id;



            // Show details



            showItemDetail(item);



        }



        /**



         * Show item details in right panel



         * - Resolves image



         * - Shows all item properties



         */



        function showItemDetail(item) {



            const categoryLabels = {



                equipement: '&#x2694;&#xFE0F; &Eacute;quipement',



                consommable: '&#x1F9EA; Consommable',



                agricole: '&#x1F33E; Agricole'



            };



            const scrollCategory = getScrollCategory(item);



            const isCurrency = item?.isCurrency === true;



            if (scrollCategory) {



                const { counts, hasStored } = loadScrollCounts(scrollCategory, item);



                if (hasStored) {



                    const total = sumScrollCounts(counts);



                    if (Number.isFinite(total) && item.quantity !== total) {



                        item.quantity = total;



                        persistInventory();



                    }



                }



            }



            const actionHtml = isCurrency



                ? ''



                : `



                    <div class="detail-actions">



                        <button class="item-action-use tw-press"



                                onclick="useItem(${item.id})"



                                title="Utiliser l'objet"



                                ${item.quantity < 1 ? 'disabled' : ''}



                                aria-label="Utiliser l'objet">



                            &#x2728;



                        </button>



                        <div class="action-stack">



                            <button class="item-action-delete tw-press"



                                    onclick="openDeleteModal(${item.id})"



                                    title="Supprimer l'objet"



                                    aria-label="Supprimer l'objet">



                                &#x1F5D1;&#xFE0F;



                            </button>



                            <button class="item-action-scroll-toggle tw-press"



                                    type="button"



                                    id="scrollTypesToggle"



                                    title="Types de parchemins"



                                    aria-label="Afficher les types de parchemins"



                                    aria-expanded="false"



                                    aria-controls="scrollTypesPanel">



                                &#x25BE;



                            </button>



                        </div>



                    </div>



                `;



            const priceInfo = [];



            const modifiersSectionHtml = renderModifierLines(getItemModifiers(item));



            if (item.buyPrice) priceInfo.push(`Achat: ${item.buyPrice}`);



            if (item.sellPrice) priceInfo.push(`Vente: ${item.sellPrice}`);



            const priceText = priceInfo.length > 0 ? priceInfo.join(' | ') : 'Prix non d√©fini';



            // Resolve image



            const imageSrc = resolveImage(item);



            detailPanel.innerHTML = `



                <div class="detail-header">



                    <div class="detail-title-wrapper">



                        <h2 class="detail-title">${escapeHtml(item.name)}</h2>



                        <span class="detail-category">${categoryLabels[item.category] || 'Autre'}</span>



                    </div>



                    ${actionHtml}



                </div>



                <div class="detail-image">



                    <img src="${escapeHtml(imageSrc)}"



                         alt="${escapeHtml(item.name)}"



                         decoding="async"



                         onerror="this.src='${PLACEHOLDER_IMAGE}'">



                </div>



                <div class="detail-body">



                    <div class="detail-section">



                        <span class="detail-label">Description</span>



                        <p class="detail-text">${escapeHtml(item.description || 'Aucune description disponible.')}</p>



                    </div>



                    ${item.effect ? `



                    <div class="detail-section">



                        <span class="detail-label">Effet</span>



                        <p class="detail-text detail-effect">${escapeHtml(item.effect)}</p>



                    </div>



                    ` : ''}



                    <div class="detail-section">



                        <span class="detail-label">Commerce</span>



                        <p class="detail-text">${escapeHtml(priceText)}</p>



                    </div>



                    ${(item.quantity > 1 || isCurrency) ? `



                    <div class="detail-section">



                        <span class="detail-label">Quantit√©</span>



                        <p class="detail-text">x${item.quantity}</p>



                    </div>



                    ` : ''}



                </div>



            `;



            scrollPanelToggleBtn = detailPanel.querySelector("#scrollTypesToggle");



            if (scrollPanelToggleBtn) {



                scrollPanelToggleBtn.addEventListener("click", () => {



                    if (scrollPanelToggleBtn.disabled) return;



                    setScrollPanelOpen(!scrollPanelOpen);



                    if (scrollPanelOpen && scrollPanelCategory && currentScrollItem) {



                        const { counts } = loadScrollCounts(scrollPanelCategory, currentScrollItem);



                        renderScrollPanelList(scrollPanelCategory, counts);



                    }



                });



            }



            setScrollPanelOpen(scrollPanelOpen);



            updateScrollPanelForItem(item);



        }



        function showDetailPlaceholder() {



            detailPanel.innerHTML = `



                <div class="detail-placeholder">



                    <div class="placeholder-icon">&#x1F446;</div>



                    <p>S√©lectionnez un objet pour voir ses d√©tails</p>



                </div>



            `;



            scrollPanelToggleBtn = null;



            scrollPanelCategory = null;



            selectedScrollTypeKey = null;



            lastScrollItemId = null;



            currentScrollItem = null;



            scrollAddOpen = false;



            if (scrollPanelAddBtn) {



                scrollPanelAddBtn.disabled = true;



            }



            setScrollAddOpen(false);



            setScrollPanelOpen(false);



            setScrollPanelEmpty("Aucun type de parchemin disponible.");



        }



        // =================================================================



        // ITEM ACTIONS (USE & DELETE)



        // =================================================================



        // Delete modal elements



        const deleteModal = document.getElementById('deleteModal');



        const deleteItemNameEl = document.getElementById('deleteItemName');



        const deleteQuantityInput = document.getElementById('deleteQuantityInput');



        const deleteQtyMinusBtn = document.getElementById('deleteQtyMinus');



        const deleteQtyPlusBtn = document.getElementById('deleteQtyPlus');



        const cancelDeleteBtn = document.getElementById('cancelDelete');



        const confirmDeleteBtn = document.getElementById('confirmDelete');



        let currentDeleteItemId = null;



        let currentDeleteItemMaxQty = 0;



        /**



         * Use an item - decreases quantity by 1



         * - Finds item by ID



         * - Decreases quantity by 1



         * - If quantity reaches 0, removes item



         * - Saves to localStorage



         * - Re-renders grid and details



         */



        function useItem(itemId) {



            const itemIndex = inventoryItems.findIndex(i => i.id === itemId);



            if (itemIndex === -1) return;



            const item = inventoryItems[itemIndex];



            if (item?.isCurrency) return;



            if (item.quantity < 1) {



                alert('Quantit√© insuffisante pour utiliser cet objet');



                return;



            }



            // Decrease quantity



            item.quantity -= 1;



            console.log(`Used ${item.name}. Quantity now: ${item.quantity}`);



            // If quantity reaches 0, remove item



            if (item.quantity <= 0) {



                resetScrollCountsAfterQtyChange(item);



                inventoryItems.splice(itemIndex, 1);



                selectedItemIndex = null;



                showDetailPlaceholder();



            } else {



                resetScrollCountsAfterQtyChange(item);



                // Refresh the detail view to update quantity display



                showItemDetail(item);



            }



            // Save to localStorage



            persistInventory();



            // Re-render grid



            renderInventory();



        }



        /**



         * Open delete confirmation modal



         * - Sets current item ID



         * - Shows item name



         * - Resets quantity input to 1



         * - Sets max quantity



         * - Opens modal



         */



        function openDeleteModal(itemId) {



            const item = inventoryItems.find(i => i.id === itemId);



            if (!item) return;



            if (item.isCurrency) return;



            currentDeleteItemId = itemId;



            currentDeleteItemMaxQty = item.quantity;



            // Update modal content



            deleteItemNameEl.textContent = item.name;



            deleteQuantityInput.value = 1;



            deleteQuantityInput.max = item.quantity;



            // Open modal



            deleteModal.classList.add('open');



        }



        /**



         * Close delete modal



         */



        function closeDeleteModal() {



            deleteModal.classList.remove('open');



            currentDeleteItemId = null;



            currentDeleteItemMaxQty = 0;



        }



        /**



         * Confirm deletion from modal



         * - Gets quantity to delete



         * - Updates item quantity or removes item



         * - Saves to localStorage



         * - Re-renders grid



         */



        function confirmDeletion() {



            if (!currentDeleteItemId) return;



            const qtyToDelete = parseInt(deleteQuantityInput.value) || 1;



            if (qtyToDelete < 1) {



                alert('La quantit√© doit √™tre au moins 1');



                return;



            }



            if (qtyToDelete > currentDeleteItemMaxQty) {



                alert(`La quantit√© maximum est ${currentDeleteItemMaxQty}`);



                return;



            }



            const itemIndex = inventoryItems.findIndex(i => i.id === currentDeleteItemId);



            if (itemIndex === -1) return;



            const item = inventoryItems[itemIndex];



            // Update quantity or remove item



            if (qtyToDelete >= item.quantity) {



                // Remove item entirely



                resetScrollCountsAfterQtyChange(item);



                inventoryItems.splice(itemIndex, 1);



                selectedItemIndex = null;



                showDetailPlaceholder();



                console.log(`Deleted ${item.name} completely`);



            } else {



                // Decrease quantity



                item.quantity -= qtyToDelete;



                resetScrollCountsAfterQtyChange(item);



                showItemDetail(item);



                console.log(`Deleted ${qtyToDelete} of ${item.name}. Remaining: ${item.quantity}`);



            }



            // Save to localStorage



            persistInventory();



            // Close modal and re-render



            closeDeleteModal();



            renderInventory();



        }



        /**



         * Decrease delete quantity



         */



        function decreaseDeleteQuantity() {



            const current = parseInt(deleteQuantityInput.value) || 1;



            deleteQuantityInput.value = Math.max(1, current - 1);



        }



        /**



         * Increase delete quantity



         */



        function increaseDeleteQuantity() {



            const current = parseInt(deleteQuantityInput.value) || 1;



            const max = currentDeleteItemMaxQty;



            deleteQuantityInput.value = Math.min(max, current + 1);



        }



        // Attach event listeners for delete modal



        deleteQtyMinusBtn.addEventListener('click', decreaseDeleteQuantity);



        deleteQtyPlusBtn.addEventListener('click', increaseDeleteQuantity);



        cancelDeleteBtn.addEventListener('click', closeDeleteModal);



        confirmDeleteBtn.addEventListener('click', confirmDeletion);



        // Close modal when clicking outside



        deleteModal.addEventListener('click', (e) => {



            if (e.target === deleteModal) {



                closeDeleteModal();



            }



        });



        // Make functions globally accessible for onclick handlers



        window.useItem = useItem;



        window.openDeleteModal = openDeleteModal;



        // =================================================================



        // ITEM DELETION (OLD - KEPT FOR COMPATIBILITY)



        // =================================================================



        /**



         * Delete an item from inventory



         * - Removes from array



         * - Saves to localStorage



         * - Clears selection



         * - Re-renders grid



         */



        function deleteItem(itemId) {



            const itemIndex = inventoryItems.findIndex(i => i.id === itemId);



            if (itemIndex === -1) return;



            const itemName = inventoryItems[itemIndex].name;



            if (inventoryItems[itemIndex].isCurrency) return;



            // Confirm deletion



            if (!confirm(`Supprimer "${itemName}" de l'inventaire ?`)) {



                return;



            }



            // Remove from array



            resetScrollCountsAfterQtyChange(inventoryItems[itemIndex]);



            inventoryItems.splice(itemIndex, 1);



            // Save to localStorage



            persistInventory();



            // Clear selection



            selectedItemIndex = null;



            showDetailPlaceholder();



            // Re-render



            renderInventory();



        }



        // Make deleteItem globally accessible for onclick



        window.deleteItem = deleteItem;



        // =================================================================



        // UTILITIES



        // =================================================================



        /**



         * Escape HTML to prevent XSS



         */



        function escapeHtml(str) {



            if (!str) return '';



            return String(str)



                .replace(/&/g, '&amp;')



                .replace(/</g, '&lt;')



                .replace(/>/g, '&gt;')



                .replace(/"/g, '&quot;')



                .replace(/'/g, '&#039;');



        }



        // =================================================================



        // ENTRY POINT



        // =================================================================



        /**



         * Initialize on page load



         */



        window.addEventListener('DOMContentLoaded', initInventory);



        window.addEventListener('astoria:character-updated', async (event) => {



            const detail = event?.detail || {};



            if (detail?.profile_data) {



                await loadCharacterSilhouette();



            }



            const next = Number(detail?.kaels);



            if (!Number.isFinite(next)) return;



            const currency = inventoryItems.find((item) => item?.isCurrency);



            if (!currency) return;



            currency.quantity = Math.max(0, Math.floor(next));



            // Persist kaels changes to database
            persistInventory();



            renderInventory();



            if (selectedItemIndex === currency.id) {



                showItemDetail(currency);



            }



        });



        /**



         * Expose API for external use



         * - Can be called from codex.html or other pages



         */



        window.InventoryModule = {



            // Current state



            items: () => inventoryItems,



            // Core functions



            renderInventory,



            filterByCategory,



            // Add item from external page (e.g., codex.html)



            addItemFromExternal: (itemName, quantity = 1) => {



                const allItems = getAllItems();



                const sourceItem = allItems.find(i => i.name === itemName);



                const sourceIndex = allItems.indexOf(sourceItem);



                if (!sourceItem) {



                    console.error(`Item not found: ${itemName}`);



                    return false;



                }



                const existingItem = inventoryItems.find(i => i.sourceIndex === sourceIndex || i.name === itemName);



                if (existingItem) {



                    existingItem.quantity += quantity;



                    if (!Number.isFinite(Number(existingItem.sourceIndex)) && Number.isFinite(sourceIndex)) {



                        existingItem.sourceIndex = sourceIndex;



                    }



                } else {



                    inventoryItems.push({



                        id: nextItemId++,



                        sourceIndex,



                        ...sourceItem,



                        quantity: quantity



                    });



                }



                persistInventory();



                renderInventory();



                return true;



            },



            // Clear entire inventory (for testing)



            clearAll: () => {



                if (confirm('Effacer tout l\'inventaire ?')) {



                    inventoryItems = [];



                    equippedSlots = {};



                    nextItemId = 1;



                    persistInventory();



                    renderInventory();



                    console.log('Inventory cleared');



                }



            }



        };



        })();



    </script>



    <script src="js/sidebar.js"></script>



</body>



</html>



